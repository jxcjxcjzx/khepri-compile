/**
 * @fileOverview Khepri peephole optimization.
 */
package (
    optimize)
with
    import 'bes::record' record,
    import 'bes::array' array,

    import 'hashtrie' hashtrie,
    
    import 'khepri-ast-zipper' {khepriZipper},
    import 'neith::zipper' {detach},
    import 'neith::walk' {'walk': neithWalk},
    import 'neith::tree' tree,

    import 'khepri-ast::node' ast_node#{Node setUserData setData},
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    
    import 'akh::base' {
        next
        'sequence': seq
        'sequencea': seqa},
    
    import 'akh::unique' Unique,
    import 'akh::trans::state' StateT,

    import 'zipper-m::trans::zipper' ZipperT,
    import 'zipper-m::walk' walk,
    
    import './ast' {
        getUid
        isLambda
        isPrimitive
        isNumberish
        isTruthy},
    import './builtin' {builtins definitions},
    import './fun' fun#{flattenr flatten}
in {

var _check;

var State := record.declare(null, [
    'bindings',
    'working',
    'globals',
    'outer',
    'ctx']);

/* Operations
 ******************************************************************************/
var M = ZipperT (StateT Unique);

var run = \c ctx state seed ->
    Unique.runUnique(
        StateT.evalStateT(
            ZipperT.runZipperT(c, ctx),
            state),
        seed);

var pass = M.of null;

/*
 ******************************************************************************/
var node =  M.node;

var modify = M.modifyNode;
var set = M.setNode;

var up = M.up;
var down = M.down;
var right = M.right;

var moveChild =  M.child;

/*
 ******************************************************************************/
var unique = M.liftInner (Unique.unique);

var addBinding = \uid target ->
    M.lift <| M.inner.modify(\s ->
        s.setBindings(hashtrie.set(uid, target, s.bindings)));

var addWorking = \uid target ->
    M.lift <| M.inner.modify(\s ->
        s.setWorking(hashtrie.set(uid, target, s.working)));

var getBinding = \uid ->
    ?uid
        :M.lift(M.inner.get).map(\{bindings working}->
            hashtrie.get(uid, working) || hashtrie.get(uid, bindings))
        :pass;

var addGlobal = \name ->
    M.lift <| M.inner.modify\s ->
        s.setGlobals(hashtrie.set(name, name, s.globals));

var globals = (M.lift M.inner.get).map\s -> s.globals;

var stack = (M.lift <| M.inner.get).map(\s -> s.stack);

var push = M.lift <| M.inner.modify(\s ->
    new State(s.bindings, hashtrie.empty, s.globals, s));

var pop = M.lift <| M.inner.modify\s ->
    s.outer
        .setBindings(s.bindings)
        .setGlobals(s.globals)
        .setWorking(
            // Delete working bindings modified in inner from outer scope.
            hashtrie.fold(
                \p {key} ->
                    hashtrie.set(key, null, p),
                s.outer.working,
                s.working));

/**
 * Create a new lexical block for body.
 */
var block = \body(...) ->
    seq(
        push,
        seqa(body),
        pop);

/*
 ******************************************************************************/
var rewrite = \base list root ->
    neithWalk(
        \ctx ->
            let node = tree.node(ctx), uid = getUid(node) in
            ?list.indexOf(uid) >= 0
                :tree.modifyNode(\node ->
                    setData(node, 'uid', base + '-' + uid), ctx)
                :ctx,
        \x -> x,
        khepriZipper(root))
            |> tree.node;
/*
 ******************************************************************************/
var checkTop = node.chain \ x -> _check x; // forward

var child = \args(edge ...) ->
    seq(
        moveChild edge,
        seqa([].slice.call(args, 1)),
        up);

var checkChild = \edge ->
    child(edge,
        checkTop);

var when = \test consequent alternate ->
    node.chain \ node ->
        ?test node
            :consequent
            :(alternate || pass);

/*
 ******************************************************************************/
var Expansion = record.declare(null, [
    'ctx',
    'id',
    'target']);

Expansion.prototype.children = [];

var isExpansion := (_ instanceof, Expansion);

var getCtx = M.lift(M.inner.get).map\s -> s.ctx;
var modifyCtx = \f -> M.lift(M.inner.modify(\s -> s.setCtx(f(s.ctx))));

var createExpansion = \id, target ->
    getCtx.map \ ctx ->
        new Expansion(ctx, id, target);

var expand = \exp f ->
    ?isExpansion exp
        :getCtx.chain \ ctx ->
            ?hashtrie.has(getUid exp.id, ctx)
                :f(exp.id)
                :seq(
                    modifyCtx\ctx -> hashtrie.set(getUid exp.id, ctx),
                    f(exp.target),
                    modifyCtx\ctx -> hashtrie.remove(getUid exp.id, ctx))
        :f(exp);

/*
 ******************************************************************************/
var UP := true,
    DOWN := false;

var peepholes = {};

var addRewrite = \type f -> {
    if (Array.isArray type)
        type.forEach \ type -> addRewrite(type, f);
    else
        peepholes.(type) = f;
};

/* Operator To Function
 ******************************************************************************/
/**
 * Convert Unary Op Expression to function.
 */
addRewrite@'UnaryOperatorExpression' <|
    seq(
        node.chain \ {op} ->
            seq(
                addGlobal(op),
                set <| builtins.(op)),
        checkTop);

/**
 * Convert binary op expression to function.
 */
addRewrite@'BinaryOperatorExpression' <|
    seq(
        node.chain \ {op flipped} ->
            let name = ?flipped : '_' + op : op in
                seq(
                    addGlobal(name),
                    set <| builtins.(name)),
        checkTop);

/**
 * Convert ternary op expression to function.
 */
addRewrite@'TernaryOperatorExpression' <|
    seq(
        addGlobal('?'),
        set <| builtins.('?'),
        checkTop);

/* 
 ******************************************************************************/
// Program and Packages
addRewrite@'Program' <|
    checkChild 'body';

addRewrite@'Package' <|
    checkChild 'body';

// Clause
addRewrite@'SwitchCase' <|
    seq(
        checkChild 'test',
        checkChild 'consequent');

addRewrite@'CatchClause' <|
    seq(
        checkChild 'param',
        checkChild 'body');

// Declarations
addRewrite@['StaticDeclaration', 'VariableDeclaration'] <|
    checkChild 'declarations';

/**
 * Register constants bound in immutable variable declarations.
 * 
 * This also removes the declarations since it will be unused, unless it is the
 * only declaration of a var bound immutable to itself.
 */
addRewrite@'VariableDeclarator' <|
    seq(
        checkChild 'init',
        node.chain \ node ->
            ?node.init
                :?node.immutable
                    :addBinding(getUid(node.id), node.init)
                    :addWorking(getUid(node.id), node.init)
            :pass);

/**
 * Register constants bound in immutable variable declarations.
 * 
 * This also removes the declarations since it will be unused, unless it is the
 * only declaration of a var bound immutable to itself.
 */
addRewrite@'Binding' <| seq(
    checkChild 'value',
    
    /**
     * Register constants bound in immutable variable declarations.
     */
    when(
        \node ->
            (  node.pattern.type === 'IdentifierPattern'
            && getUid node.pattern.id),
        
        node.chain \ node ->
            let uid = getUid(node.pattern.id) in
                ?isPrimitive(node.value)
                    :addBinding(uid, node.value)
                    
                :?isLambda(node.value)
                    :createExpansion(node.pattern.id, node.value).chain\entry ->
                        addBinding(uid, entry)
                    
                :?node.value.type === 'Identifier'
                    :getBinding(getUid node.value).chain \ binding ->
                        ?binding
                            :addBinding(uid, node.value)
                            :pass
                    
                :pass),
    
    /**
     * Expand a binding of a let expression to a set of bindings, with the top level
     * binding to the let body last.
     */
    when(
        \node ->
            (node.value.type === 'LetExpression'),
        
        node.chain \ node -> let
            bindings =
                fun.flatten <| fun.concat(
                   node.value.bindings,
                   ast_declaration.Binding.create(null,
                       node.pattern,
                       node.value.body))
       in
           seq(
               set bindings,
               checkChild(bindings.length - 1))));

// Statement
addRewrite@'BlockStatement' <|
    checkChild 'body';

addRewrite@'ExpressionStatement' <|
    checkChild 'expression';

addRewrite@'WithStatement' <|
     seq(
        checkChild 'bindings',
        checkChild 'body');

addRewrite@'SwitchStatement' <|
    seq(
        checkChild 'discriminant',
        checkChild 'cases');

addRewrite@['ReturnStatement', 'ThrowStatement'] <|
    checkChild 'argument';

addRewrite@'TryStatement' <|
    seq(
        checkChild 'block',
        checkChild 'handler',
        checkChild 'finalizer');

addRewrite@'WhileStatement' <|
    block(
        checkChild 'test',
        checkChild 'body');

addRewrite@'DoWhileStatement' <|
    block(
        checkChild 'body',
        checkChild 'test');

addRewrite@'ForStatement' <|
    seq(
        checkChild 'init',
        block(
            checkChild 'test',
            checkChild 'update',
            checkChild 'body'));

// Expression
addRewrite@'FunctionExpression' <|
    block(
         checkChild 'id',
         checkChild 'params',
         checkChild 'body');

addRewrite@'UnaryExpression' <| let
    arithmetic = {
        '!': (!),
        '~': (~),
        'typeof': (typeof),
        '++': (++),
        '--': (--)}
in
    /**
     * Combine simple unary operations on primitive literals
     */
    when(
        \{operator argument} ->
            (  arithmetic.(operator)
            && isPrimitive(argument)),
    
        modify \ {operator argument} -> let
            value = arithmetic.(operator)(argument.value)
        in
            ast_value.Literal.create(null, typeof value, value));

addRewrite@'AssignmentExpression' <| seq(
    checkChild 'right',
    
    /**
     * Update the working value of a binding.
     */
    when(
        \{left} ->
            left.type === 'Identifier',
        
        node.chain \ node ->
            addWorking(getUid(node.left), node.right)));

/**
 * Combine binary arithmetic operations on primitive literals.
 * 
 * TODO: Shortcircuit expansion for logical ops.
 */
addRewrite@['LogicalExpression', 'BinaryExpression'] <| let
    arithmetic = {
        '+': (+),
        '-': (-),
        '*': (*),
        '/': (/),
        '%': (%),
        '<<': (<<),
        '>>': (>>),
        '>>>': (>>>),
        '<': (<),
        '>': (>),
        '<=': (<=),
        '>=': (>=),
        '||': (||),
        '&&': (&&)}
in
    seq(
        checkChild 'left',
        checkChild 'right',
        when(
            \{operator left right} ->
                (  arithmetic.(operator)
                && isPrimitive(left)
                && isPrimitive(right)),
            
            modify \ {operator left right} -> let
                value = arithmetic.(operator)(left.value, right.value)
            in
                ast_value.Literal.create(null, typeof value, value)));

/**
 * Reduce conditionals with constant test.
 */
addRewrite@['ConditionalExpression', 'IfStatement'] <|
    seq(
        checkChild 'test',
        when(
            \node ->
                isPrimitive node.test,
            
            node.chain \ {test consequent alternate} ->
                seq(
                    set ?isTruthy test : consequent : alternate,
                    checkTop),
            
            seq(
                checkChild 'consequent',
                checkChild 'alternate')));

addRewrite@'MemberExpression' <|
    seq(
        checkChild 'object',
        node.chain \ node ->
            ?node.computed
                :checkChild 'property'
                :pass);

addRewrite@'NewExpression' <|
    seq(
        checkChild 'callee',
        checkChild 'args');

addRewrite@'CallExpression' <| seq(
    checkChild 'callee',
    checkChild 'args',
    
    /**
     * Inline calls of lambda functions by expanding them to let expressions.
     * 
     * The let expression is then rewritten to ensure the resulting values are unique.
     */
    when(
        \node ->
            (  isLambda(node.callee)
            || isExpansion(node.callee)
            || (node.callee.type === 'LetExpression' && isLambda(node.callee.body))),
        
        (node.chain\node -> expand(node.callee, \ callee ->
            seq(
                unique.chain \ uid ->
                modify \ node -> ?callee.type === 'Identifier': ast_expression.CallExpression.create(node.loc, callee, node.args) : let
                    target = ?callee.type === 'LetExpression' : callee.body : callee,
                    
                    map = target.params.elements.map(\x -> getUid(x.id)),
                    
                    bindings =
                        target.params.elements.map \ x i ->
                            ast_declaration.Binding.create(null,
                                x,
                                ?node.args.(i)
                                    :node.args.(i)
                                    :ast_value.Identifier.create(null, 'undefined'))
                in
                    rewrite(uid, map, ast_expression.LetExpression.create(null,
                        fun.concat(
                            callee.bindings || [],
                            bindings),
                        target.body)),
             ?callee.type === 'Identifier' :pass: checkTop)))));

addRewrite@'CurryExpression' <| seq(
    checkChild 'base',
    checkChild 'args',
    
    /**
     * Convert curry on function expression to function.
     * 
     * Discards arguments that are not used.
     */
    when(
        \node ->
            (  isLambda(node.base)
            || (node.base.type === 'LetExpression' && isLambda(node.base.body))),

        seq(
            unique.chain \ uid ->
            modify \ node -> let
                target = ?node.base.type === 'LetExpression' : node.base.body : node.base
            in
                ?!target.params.elements.length
                    :node.base
                    :let
                        first = target.params.elements.(0),
                        rest = target.params.elements.slice(1),
                        
                        map = [getUid(first.id)],
                        
                        body = ast_expression.FunctionExpression.create(null, null,
                            ast_pattern.ArgumentsPattern.create(null, null,
                                rest,
                                target.params.self),
                            rewrite(uid, map, target.body))
                    in
                        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
                            :ast_expression.LetExpression.create(null,
                                fun.concat(
                                    node.base.bindings || [],
                                    rewrite(uid, map, ast_declaration.Binding.create(null,
                                        first,
                                        node.args.(0)))),
                                body)
                            :body,
                checkTop)));

addRewrite@'ArrayExpression' <|
    checkChild 'elements';

addRewrite@'ObjectExpression' <|
    checkChild 'properties';

/**
 * Flatten let expression bindings.
 */
addRewrite@'LetExpression' <|
    seq(
        checkChild 'bindings',
        checkChild 'body',
        modify \ {loc bindings body} ->
            ast_expression.LetExpression.create(loc,
                flattenr(bindings),
                body),
        when(
            \{bindings} ->
                !bindings.length,
            
            modify \ {body} ->
                body));



// Patterns
addRewrite@'IdentifierPattern' <|
    checkChild 'id';

addRewrite@'AsPattern' <|
    seq(
        checkChild 'id',
        checkChild 'target');

addRewrite@'ObjectPattern' <|
    checkChild 'elements';

addRewrite@'ObjectPatternElement' <|
    seq(
        checkChild 'target',
        checkChild 'key');

addRewrite@'ArgumentsPattern' <|
    seq(
        checkChild 'id',
        checkChild 'elements',
        checkChild 'self');

// Value
addRewrite@'ObjectValue' <|
    checkChild 'value';

addRewrite@'Identifier' <|
    when(
        \node -> getUid node,
        
        node.chain \ node ->
            getBinding(getUid node).chain \ binding ->
                ?binding && (isPrimitive(binding) || binding.type === 'Identifier' || isLambda(binding) || isExpansion(binding))
                    :set(binding)
                    :pass);

/* Interface
 ******************************************************************************/
_check = \node -> {
    if (Array.isArray(node)) {
        if (!node.length)
            return pass;
        
        return seq(
            down,
            seqa(node.map(\_ i -> 
                ?i === node.length - 1
                    :checkTop
                    :next(checkTop, right))),
            up);
    }
    
    if (node instanceof ast_node.Node && peepholes.(node.type))
        return peepholes.(node.type);
    
    return pass;
};

var initialState = Object.keys(builtins).reduce(
    \s name -> let
        id = builtins.(name),
        def = definitions.(name)
    in
        s.setBindings(
            hashtrie.set(getUid id, def, s.bindings)),
    new State(
        hashtrie.empty,
        hashtrie.empty,
        hashtrie.empty,
        null,
        hashtrie.empty));

/**
 * 
 */
optimize = \ast data ->
    run(
        next(
            checkTop,
            node.chain \ node ->
            globals.chain \ g ->
            unique.chain \ unique ->
                M.of({
                    'tree': node,
                    'data': {'globals': hashtrie.keys(g), 'unique': unique}
                })),
        khepriZipper(ast),
        initialState,
        data.unique);

}

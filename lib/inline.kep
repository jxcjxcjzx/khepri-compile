/**
 * @fileOverview Khepri peephole optimization.
 */
package (
    optimize)
with
    import 'bes::record' record,
    import 'bes::array' array,

    import 'hashtrie' hashtrie,
    
    import 'khepri-ast-zipper' {khepriZipper},
    import 'neith::walk' {'walk': neithWalk},
    import 'neith::tree' tree,

    import 'khepri-ast::node' {Node setUserData setData},
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    
    import 'akh::base' {
        next
        'sequence': seq
        'sequencea': seqa},
    
    import 'akh::unique' Unique,
    import 'akh::trans::state' StateT,

    import 'zipper-m::trans::zipper' ZipperT,
    import 'zipper-m::walk' walk,
    
    import './builtin' {builtins definitions},
    import './ast' {isLambda},
    import './fun' fun
in {

var State := record.declare(null, [
    'bindings',
    'globals']);

/* Operations
 ******************************************************************************/
var M = ZipperT (StateT Unique);

var run = \c ctx state seed ->
    Unique.runUnique(
        StateT.evalStateT(
            ZipperT.runZipperT(c, ctx),
            state),
        seed);

var pass = M.of null;

var node =  M.node;

var modify = M.modifyNode;
var set = M.setNode;

var unique = M.liftInner (Unique.unique);

var addBinding = \uid target ->
    M.lift <| M.inner.modify(\s ->
        s.setBindings(hashtrie.set(uid, target, s.bindings)));

var getBinding = \uid ->
    ?uid
        :M.lift(M.inner.get).map(\{bindings}->
            hashtrie.get(uid, bindings))
        :pass;

var addGlobal = \name ->
    M.lift <| M.inner.modify\s ->
        s.setGlobals(hashtrie.set(name, name, s.globals));

var globals = (M.lift M.inner.get).map\s -> s.globals;

var stack = (M.lift <| M.inner.get).map(\s -> s.stack);

var push = M.lift <| M.inner.modify(\s ->
    s.setStack(array.push(s.stack, null)));

var pop = M.lift <| M.inner.modify(\s ->
    s.setStack(array.pop(s.stack)));

var rewrite = \base list root ->
    neithWalk(
        \ctx -> let node = tree.node(ctx) in
            ?node && node.ud && node.ud.uid && list.indexOf(node.ud.uid) !== --1
                :tree.modifyNode(\node ->
                    setData(node, 'uid', base + '-' + node.ud.uid), ctx)
                :ctx,
        \x -> x,
        khepriZipper(root))
            |> tree.node;

/*
 ******************************************************************************/
var peepholes = {};

var addPeephole = \types up test f -> {
    var entry = {
        'condition': test,
        'up': up,
        'map': f
    };
    
    types.forEach \ type -> {
        peepholes.(type) = ?peepholes.(type)
            :fun.concat(peepholes.(type), entry)
            :[entry];
    };
};

var always = \_ -> true;

/* Operator To Function
 ******************************************************************************/
/**
 * Convert Unary Op Expression to function.
 */
addPeephole(['UnaryOperatorExpression'], false,
    always,
    node.chain \ {op} ->
        seq(
            addGlobal(op),
            set <| builtins.(op)));

/**
 * Convert binary op expression to function.
 */
addPeephole(['BinaryOperatorExpression'], false,
    always,
    node.chain \ {op flipped} ->
        let name = ?flipped : '_' + op : op in
            seq(
                addGlobal(name),
                set <| builtins.(name)));

/**
 * Convert ternary op expression to function.
 */
addPeephole(['TernaryOperatorExpression'], false,
    always,
    seq(
        addGlobal('?'),
        set <| builtins.('?')));

/* 
 ******************************************************************************/
/**
 */
addPeephole(['VariableDeclarator'], true,
    \node -> 
        (  node.immutable
        && node.init
        && isLambda(node.init)
        && false),
    node.chain \ node ->
        addBinding(node.id.ud.uid, node.init));

/**
 * 
 */
addPeephole(['Binding'], true, 
    \node -> 
        (  node.pattern.id
        && node.pattern.id.ud
        && !node.recursive
        && isLambda(node.value)),
    node.chain \ node ->
        addBinding(node.pattern.id.ud.uid, node.value));

/* Inlining
 ******************************************************************************/
addPeephole(['CallExpression'], true,
    \node ->
        (node.callee.type === 'Identifier' && node.callee.ud.uid),

    node.chain \ node ->
        getBinding(node.callee.ud.uid).chain \ binding ->
            ?binding
                :modify \ node ->
                    ast_expression.CallExpression.create(null,
                        binding,
                        node.args)
                :pass);

addPeephole(['CurryExpression'], true,
    \node ->
        (node.base.type === 'Identifier' && node.base.ud.uid),

    node.chain \ node ->
        getBinding(node.base.ud.uid).chain \ binding ->
            ?binding
                :modify \ node ->
                    ast_expression.CurryExpression.create(null,
                        binding,
                        node.args)
                :pass);

/* Inline Expansion
 ******************************************************************************/
/**
 * Inline calls of lambda functions by expanding them to let expressions.
 * 
 * The let expression is then rewritten to ensure the resulting values are unique.
 */
addPeephole(['CallExpression'], true,
    \node ->
        isLambda(node.callee),
    
    unique.chain \ uid ->
        modify \ node -> let
            map = node.callee.params.elements.map(\x -> x.id.ud.uid),
            
            bindings =
                node.callee.params.elements.map \ x i ->
                    ast_declaration.Binding.create(null,
                        rewrite(uid, map, x),
                        ?node.args.(i)
                            :node.args.(i)
                            :ast_value.Identifier.create(null, 'undefined'))
        in
            ast_expression.LetExpression.create(null,
                bindings,
                rewrite(uid, map, node.callee.body)));

/**
 * 
 */
addPeephole(['CallExpression'], true,
    \node ->
        (  node.callee.type === 'LetExpression'
        && node.callee.body.type === 'FunctionExpression'),
    
    unique.chain \ uid ->
        modify \ node -> let
            map = node.callee.body.params.elements.map(\x -> x.id.ud.uid),
    
            bindings =
                node.callee.body.params.elements.map \ x i ->
                    ast_declaration.Binding.create(null,
                        rewrite(uid, map, x),
                        ?node.args.(i)
                            :node.args.(i)
                            :ast_value.Identifier.create(null, 'undefined'))
        in
            ast_expression.LetExpression.create(null,
                fun.concat(
                    node.callee.bindings,
                    bindings),
                rewrite(uid, map, node.callee.body.body)));

/**
 * Rewrite call of curried expression to a call direct call on curry base.
 */
addPeephole(['CallExpression'], true,
    \{callee} ->
        callee.type ==='CurryExpression',
   
    modify \ node ->
        ast_expression.CallExpression.create(null,
            node.callee.base,
            fun.concat(
                node.callee.args || [],
                node.args)));

/**
 * 
 */
addPeephole(['CallExpression'], true,
    \node ->
        (  node.callee.type === 'LetExpression'
        && node.callee.body.type === 'CurryExpression'),

    modify \ node -> let
        first = node.callee.body.params.elements.(0),
        rest = node.base.body.params.elements.slice(1),
        
        body = ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null,
                rest,
                node.base.body.params.self),
            node.base.body.body)
    in
        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
            :ast_expression.LetExpression.create(null,
                fun.concat(
                    node.base.bindings,
                    ast_declaration.Binding.create(null,
                        first,
                        node.args.(0))),
                body)
            :ast_expression.LetExpression.create(null,
                node.base.bindings,
                body));

/**
 * Convert curry on function expression to function.
 * 
 * Note that this discards arguments that are not used.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        isLambda(node.base),
    
    unique.chain \ uid ->
    modify \ node ->
        ?!node.base.params.elements.length
            :node.base
            :let
                first = node.base.params.elements.(0),
                rest = node.base.params.elements.slice(1),
                
                map = [first.id.ud.uid],
                
                body = ast_expression.FunctionExpression.create(null, null,
                    ast_pattern.ArgumentsPattern.create(null, null,
                        rest,
                        node.base.params.self),
                    rewrite(uid, map, node.base.body))
            in
                ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
                    :ast_expression.LetExpression.create(null,
                        [rewrite(uid, map, ast_declaration.Binding.create(null,
                            first,
                            node.args.(0)))],
                        body)
                    :body);

/**
 * Try Convert curry on let with function body to function.
 * 
 * Note that this may discard arguments that are not used.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        (  node.base.type === 'LetExpression'
        && isLambda(node.base.body)),
    
    unique.chain \ uid -> 
    modify \ node ->
        ?!node.base.body.params.elements.length
            :node.base
        :let
            first = node.base.body.params.elements.(0),
            rest = node.base.body.params.elements.slice(1),
            
            map = [first.id.ud.uid],
    
            body = ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null,
                    rest,
                    node.base.body.params.self),
                rewrite(uid, map, node.base.body.body))
        in
            ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
                :ast_expression.LetExpression.create(null,
                    fun.concat(
                        node.base.bindings,
                        rewrite(uid, map, ast_declaration.Binding.create(null,
                            first,
                            node.args.(0)))),
                    body)
                :ast_expression.LetExpression.create(null,
                    node.base.bindings,
                    body));

/* Interface
 ******************************************************************************/
var upTransforms = \node -> 
    ((node && peepholes.(node.type)) || [])
        .filter(\x -> x.up && x.condition(node));

var downTransforms = \node -> 
    ((node && peepholes.(node.type)) || [])
        .filter(\x -> !x.up && x.condition(node));

var transform = \node transforms ->
    ?transforms.length
        :seqa(transforms.map(\x -> x.map))
        :pass;

var _transform = node.chain \ node -> 
    transform(node, downTransforms node);

var _transformPost = node.chain \ n -> let
    t = upTransforms n
in
    ?t.length
        :next(transform(n, [t.(0)]), node).chain\x -> ?x && x !== n : _transformPost : pass
        :pass;

var initialState = Object.keys(builtins).reduce(
    \s name -> let
        id = builtins.(name),
        def = definitions.(name)
    in
        s.setBindings(
            hashtrie.set(id.ud.uid, def, s.bindings)),
    new State(
        hashtrie.empty,
        hashtrie.empty));

/**
 * 
 */
optimize = \ast data ->
    run(
        next(
            walk(M, _transform, _transformPost),
            node.chain \ node ->
            globals.chain \ g ->
            unique.chain \ unique ->
                M.of({
                    'tree': node,
                    'data': {'globals': hashtrie.keys(g), 'unique': unique}
                })),
        khepriZipper(ast),
        initialState,
        data.unique);

}

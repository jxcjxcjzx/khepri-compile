/**
 * @fileOverview Khepri peephole optimization.
 */
package (
    optimize)
with
    import 'hamt' hamt,
    
    import 'akh::base' {
        next
        'sequence': seq
        'sequencea': seqa},
    
    import 'akh::state' StateM,

    import 'zipper-m::trans::tree' TreeZipperT,
    
    import './ast' {
        type
        getUid}
in {

/* State
 ******************************************************************************/
var stateEmpty = hamt.empty;

var stateAddReference = let
    inc = \x -> (x + 1 || 1)
in
    \uid bindings ->
        hamt.modify(uid, inc, bindings);

var stateGetCount = \uid bindings ->
    hamt.get(uid, bindings);

var stateIsReachable = stateGetCount;

/* Forward
 ******************************************************************************/
var _check;

var M = TreeZipperT (StateM);

var run = \c ctx ->
    StateM.evalState(
        TreeZipperT.runTreeZipperT(c, ctx),
        stateEmpty);

var pass = M.of null;

// Movement
////////////////////////////////////////
var extractCtx := M.get;

var extract := M.chain @ M.node;

var set := M.setNode;

var up := M.up;
var down := M.down;
var left := M.left;

var rightmost := M.rightmost;

var moveChild := M.child;

/**
 * Move to a child along `edge` and perform a list of operations. Return to parent.
 */
var child = \edge ...actions ->
    seq(
        moveChild edge,
        seqa actions,
        up);

/**
 * When `test` is true for current node, evaluate consequent. Otherwise evaluate
 * alternate.
 */
var when := \test consequent alternate ->
    extract \ node ->
        ?test node
            :consequent
            :(alternate || pass);

// State Operations
////////////////////////////////////////
var getState := M.lift (M.inner.get);

var modifyState := M.lift <\ M.inner.modify;

// Bindings Operations
////////////////////////////////////////
/**
 * Increment the reference count for `uid`.
 */
var addReference = \uid ->
    ?uid
        :modifyState (stateAddReference @ uid)
        :pass;

/**
 * Get the reference count for `uid`.
 */
var getCount = \uid ->
    ?uid
        :getState.map (stateGetCount @ uid)
    :M.of 0;

/**
 * If `uid` is reacahble (reference count > 0), execute `yes`. Otherwise do `no`.
 */
var isReachable = \uid yes no ->
    ?uid
        :getState.chain \ s ->
            ?stateIsReachable(uid, s) : yes : no
    :yes;

// Check Operations
////////////////////////////////////////
/**
 * Rewrite the current node.
 */
var checkTop := extract \ x -> { return _check x; }; // forward

/**
 * Rewrite a child node.
 */
var visitChild := \edge ->
    child(edge,
        checkTop);

/*
 ******************************************************************************/
var peepholes := {};

var addRewrite := \type f -> {
    if (Array.isArray type)
        type.forEach \ type -> addRewrite(type, f);
    else
        peepholes.(type) = f;
};

/* Checks
 ******************************************************************************/
// Program and Packages
addRewrite@'Program' <|
    visitChild 'body';

addRewrite@'Package' <| seq(
    visitChild 'exports', // mark all exports reachable before visiting body
    visitChild 'body');

addRewrite@'PackageExports' <|
    visitChild 'exports';

addRewrite@'PackageExport' <|
    visitChild 'id';

// Clause
addRewrite@'SwitchCase' <| seq(
    visitChild 'test',
    visitChild 'consequent');

addRewrite@'CatchClause' <| seq(
    visitChild 'param',
    visitChild 'body');

// Declarations
addRewrite@'VariableDeclaration' <|
    visitChild 'declarations';

addRewrite@'VariableDeclarator' <|
    extract \ node ->
        isReachable(getUid node.id,
            visitChild 'init',
            set []);

addRewrite@'Binding' <|
    extract \ node ->
        isReachable(getUid node.pattern.id,
            visitChild 'value',
            set []);

// Statement
addRewrite@'BlockStatement' <|
    visitChild 'body';

addRewrite@'ExpressionStatement' <|
    visitChild 'expression';

addRewrite@'WithStatement' <| seq(
    visitChild 'body',
    visitChild 'bindings');

addRewrite@'SwitchStatement' <| seq(
    visitChild 'discriminant',
    visitChild 'cases');

addRewrite@['ReturnStatement', 'ThrowStatement'] <|
    visitChild 'argument';

addRewrite@'TryStatement' <| seq(
    visitChild 'block',
    visitChild 'handler',
    visitChild 'finalizer');

addRewrite@['WhileStatement', 'DoWhileStatement'] <| seq(
    visitChild 'test',
    visitChild 'body');

addRewrite@'ForStatement' <| seq(
    visitChild 'body',
    visitChild 'update',
    visitChild 'test',
    visitChild 'init');

addRewrite@['ConditionalExpression', 'IfStatement'] <| seq(
    visitChild 'test',
    visitChild 'consequent',
    visitChild 'alternate');

addRewrite@'FunctionExpression' <| seq(
    visitChild 'id',
    visitChild 'params',
    visitChild 'body');

addRewrite@'UnaryExpression' <|
    visitChild 'argument';

addRewrite@['LogicalExpression', 'BinaryExpression'] <| seq(
    visitChild 'left',
    visitChild 'right');

addRewrite@'AssignmentExpression' <| seq(
    visitChild 'left',
    visitChild 'right');

addRewrite@'MemberExpression' <| seq(
    visitChild 'object',
    when((.computed),
        visitChild 'property'));

addRewrite@'NewExpression' <| seq(
    visitChild 'callee',
    visitChild 'args');

addRewrite@'CallExpression' <| seq(
    visitChild 'callee',
    visitChild 'args');

addRewrite@'CurryExpression' <| seq(
    visitChild 'base',
    visitChild 'args');

addRewrite@'LetExpression' <| seq(
    visitChild 'body',
    visitChild 'bindings');

// Unpack
addRewrite@'ArgumentsPattern' <|
    visitChild 'id';

// Value
addRewrite@'ArrayExpression' <|
    visitChild 'elements';

addRewrite@'ObjectExpression' <|
    visitChild 'properties';

addRewrite@'ObjectValue' <|
    visitChild 'value';

addRewrite@'Identifier' <|
    extract (getUid \> addReference);

/* Interface
 ******************************************************************************/
_check = \node -> {
    if (Array.isArray node) {
        if (!node.length) return pass;
        
        // Visit all elements of array in reverse order, from right to left.
        return seq(
            down,
            rightmost,
            node.reduceRight(\p c i ->
                next(
                    p,
                    ?i
                        :next(checkTop, left)
                        :checkTop),
                pass),
            up);
    }
    
    return (peepholes.(type node) || pass);
};

/**
 * 
 */
optimize = \ast data ->
    run(
        next(
            checkTop,
            extractCtx.chain \ node ->
                M.of({
                    'tree': node
                })),
        ast);

}
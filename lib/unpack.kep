/**
 * @fileOverview Unpack expansion.
 */
package (
    innerPattern
    unpackParameters)
with
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,

    import './fun' fun#{flatten}
in {

/**
 * Expand a complex binding to a list of identifier bindings.
 * 
 * @param base Value being unpacked.
 * @param pattern Pattern unpacking base value.
 */
innerPattern = let
    objectElementUnpack = \base, pattern, key recursive -> let
        innerBase = ast_expression.MemberExpression.create(null, base, key, true)
    in
        ?pattern
            :flatten <| innerPattern(innerBase, pattern)
            :ast_declaration.Binding.create(null,
                ast_pattern.IdentifierPattern.create(null,
                    ast_value.Identifier.create(null, key.value)),
                innerBase,
                recursive)
in
    \base pattern recursive -> {
        switch (pattern.type) {
        case 'IdentifierPattern':
            return [
                ast_declaration.Binding.create(null,
                    pattern,
                    base,
                    recursive)];
        
        case 'AsPattern':
            return fun.concat(
                innerPattern(base, pattern.id),
                flatten <| innerPattern(pattern.id, pattern.target, recursive));
        
        case 'ObjectPattern':
            return pattern.elements
                |> (fun.map @ \{target key} -> objectElementUnpack(pattern.ud.id.id, target, key, recursive))
                |> flatten;
        
        default:
            return [];
        }
    };

/**
 * Expand a parameter list to a list of inner bindings.
 */
unpackParameters = flatten <\
    fun.map @ \x -> {
        switch (x.type) {
        // Avoid generating redundant unpacks for parameters names.
        case 'SinkPattern':
        case 'IdentifierPattern':
            return [];
        case 'AsPattern':
            return flatten <| innerPattern(x.id, x.target);
        default:
            return innerPattern(x, x);
        }
    };

}
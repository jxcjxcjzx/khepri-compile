/**
 * @fileOverview 
 */
package (
    Scope
    
    addUid
    addBinding
    addMutableBinding
    addImmutableBinding
    setBindingMutability
    addMapping
    
    getClosure
    
    push
    pop
    
    addVar)
with
    import 'bes::record' record,
    
    import 'hamt' hamt
in {

var IMMUTABLE := 0,
    MUTABLE := 1,
    TRANS := 2;

/* Scope
 ******************************************************************************/
/**
 * Holds information about a lexical scope.
 * 
 * @member record Maps identifiers to binding information for this scope.
 * @member outer Parent scope.
 * @member mapping Maps identifiers to their actual names in this scope.
 * @member definitions Maps identifiers to unique ids.
 * @member locals Set of all unique ids.
 */
Scope = record.declare(null, [
    'record',
    'outer',
    'mapping',
    'definitions',
    'locals']);

Scope.empty = Scope.create(
    hamt.empty,
    null,
    hamt.empty,
    hamt.empty,
    hamt.empty);

/**
 * Does this scope have a binding for `id`?
 */
Scope.prototype.hasOwnBinding = \id =self->
    hamt.has(id, self.record);

/**
 * Does this scope or its parents have a given binding for `id`?
 */
Scope.prototype.hasBinding = \id =self->
    (  self.hasOwnBinding(id)
    || (self.outer && self.outer.hasBinding(id)));

/**
 * Does this scope or its parents have a mutable binding for `id`?
 */
Scope.prototype.hasMutableBinding = \id =self-> let
    binding = self.getBinding(id)
in
    (binding && binding.mutable);

/**
 * Get information for a given binding.
 * 
 * Returns null if binding does not exist.
 */
Scope.prototype.getBinding = \id =self->
    (  hamt.get(id, self.record)
    || ?self.outer
        :self.outer.getBinding(id)
        :null);

/**
 * Get the unique identifier for `id`.
 */
Scope.prototype.getUid = \id =self->
    ?self.hasOwnBinding(id)
        :hamt.get(id, self.definitions)
        :?self.outer
            :self.outer.getUid(id)
            :null;

/**
 * Does this scope have its own a mapping for a given identifier.
 */
Scope.prototype.hasOwnMapping = \id =self->
    hamt.has(id, self.mapping);

/**
 * Does this scope have any mapping for a given identifier.
 */
Scope.prototype.hasMapping = \id =self->
    (  self.hasOwnMapping(id)
    || (self.outer && self.outer.hasMapping(id)));

/**
 * Get the mapped value for a given identifier.
 */
Scope.prototype.getMapping = \id =self->
    ?self.hasOwnMapping(id)
        :hamt.get(id, self.mapping)
        :self.outer && self.outer.getMapping(id);

/**
 * Get an unused identifier in this scope.
 */
Scope.prototype.getUnusedId = \id =self-> {
    if (!self.hasBinding(id))
        return id;
    
    for (var i = 0; ; i = i + 1)
        if (!self.hasBinding(id + i))
            return id + i;
};

/* Operations
 ******************************************************************************/
/**
 * Register a unique identifier in scope `s`.
 * 
 * @param id Identifier
 * @param uid Unique identifier.
 * @param s Scope.
 */
addUid = \id uid s ->
    s
        .setDefinitions(
            hamt.set(id, uid, s.definitions))
        .setLocals(
            hamt.set(uid, id, s.locals));

/**
 * Create a new modified scope with a given binding.
 * 
 * @param s Scope.
 * @param id Identifier for new binding.
 * @param info Binding information.
 */
addBinding = \s id info -> 
    s.setRecord <| 
        hamt.set(id, info, s.record);

/**
 * Create a new modified scope with a new mutable binding.
 * 
 * @param s Scope
 * @param id Identifier for new binding
 * @param loc Location of binding in source code.
 */
addMutableBinding = \s, id, loc ->
    addBinding(s, id, {
        'mutable': MUTABLE,
        'loc': loc
    });

/**
 * Create a new modified scope with a new immutable binding.
 * 
 * @param s Scope
 * @param id Identifier for new binding
 * @param loc Location of binding in source code.
 */
addImmutableBinding = \s, id, loc ->
    addBinding(s, id, {
        'mutable': IMMUTABLE,
        'loc': loc
    });

/**
 * Create a new modified scope with a new immutable binding.
 * 
 * @param s Scope
 * @param id Identifier for new binding
 * @param loc Location of binding in source code.
 */
setBindingMutability = \s id mutable ->
    ?s.hasOwnBinding id
        :addBinding(s, id, {
            loc: s.getBinding(id).loc,
            mutable: ?mutable : MUTABLE : IMMUTABLE
        })
        :(s.outer && s.setOuter(setBindingMutability(s.outer, id, mutable)));

/**
 * Create a new modified scope with a new mapping
 * 
 * @param s Scope
 * @param from Key value.
 * @param to Value to map to.
 */
addMapping = \s from to ->
    s.setMapping <|
        hamt.set(from, to, s.mapping);

/**
 * Get a list of all valid uids in the current scope.
 * 
 * @param s Scope.
 */
getClosure := (.locals) \> hamt.keys;

/* Operations
 ******************************************************************************/
/**
 * Enter a new empty scope with its parent set to `s`.
 * 
 * @param s Scope.
 */
push = \s ->
    Scope.empty
        .setOuter(s)
        .setDefinitions(s.definitions);

/**
 * Pop scope.
 * 
 * @param s Scope.
 */
pop = let
    mergeLocals =
        hamt.fold @ \p {key value} -> hamt.set(key, value, p)
in
    \s ->
        s.outer
            .setLocals(
                mergeLocals(s.outer.locals, s.locals));

/**
 * Add a new identifier to scope `s`.
 * 
 * @param id Source id name.
 * @param uid Unique id.
 * @param s Scope.
 */
addVar = \id uid s ->
    ?s.hasMapping(uid)
        :addMutableBinding(s, id)
    
    :let name = s.getUnusedId(id) in
        addMapping(
            addMutableBinding(s, name),
            uid,
            name);
}
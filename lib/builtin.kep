/**
 * @fileOverview Khepri builtins.
 */
package (
    builtins
    definitions
    
    member)
with
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::node' {modify},
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,

    import './ast' {
        type
        setUd
        getUid
        setUid},
    import './fun' {
        flip}
in {

var setLocals := \node locals ->
    setUd('locals', locals, node);

var identifier = \name uid ->
    setUid(
        uid,
        ast_value.Identifier.create(null, name));

var unique = (\-> {
    var x = 0;
    return \-> {
        x = x + 1;
        return x;
    };
}());

/* Exports
 ******************************************************************************/
definitions := {};
builtins := {};

var addSymbol = \name id def -> {
    builtins.(name) = id;
    definitions.(name) = def;
};

var registerAliasedSymbol = \name alias def -> {
    addSymbol(name,
        identifier(alias, unique()),
        def);
};

/* Reserved Identifiers
 ******************************************************************************/
builtins.('require') = identifier('require', unique());
builtins.('exports') = identifier('exports', unique());
builtins.('module') = identifier('module', unique());

builtins.('undefined') = identifier('undefined', unique());

/* Unary Operators
 ******************************************************************************/
with
    unary = \op -> let
        xArg = identifier('x', unique())
    in
        setLocals(
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null, xArg)]),
                op(xArg)),
            [getUid xArg]),
    
    unaryOp = \op ->
        unary\x ->
            ast_expression.UnaryExpression.create(null, op, x)
in {
    [
        ['typeof', '__typeof'],
        ['void', '__void'],
        ['~', '__bnot'],
        ['!', '__lnot'],
        ['++', '__plus'],
        ['--', '__minus']
    ].forEach \ [op name] -> {
        registerAliasedSymbol(op, name, unaryOp(op));
    };
    
    addSymbol('_', identifier('_', unique()), unary\f ->
        let
            xArg = identifier('x', unique()),
            yArg = identifier('y', unique())
        in
            setLocals(
                ast_expression.FunctionExpression.create(null, null,
                    ast_pattern.ArgumentsPattern.create(null, null, [
                        ast_pattern.IdentifierPattern.create(null, xArg),
                        ast_pattern.IdentifierPattern.create(null, yArg)]),
                    ast_expression.CallExpression.create(null, f, [yArg, xArg])),
                [getUid xArg, getUid yArg]));
}


/* Ternary Operator
 ******************************************************************************/
with
    ternaryOperator = let
        xArg = identifier('x', unique()),
        yArg = identifier('y', unique()),
        zArg = identifier('z', unique())
    in
        setLocals(
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null,
                        xArg),
                    ast_pattern.IdentifierPattern.create(null,
                        yArg),
                        ast_pattern.IdentifierPattern.create(null,
                        zArg)]),
                ast_expression.ConditionalExpression.create(null,
                    xArg,
                    yArg,
                    zArg)),
            [getUid xArg, getUid yArg, getUid zArg])
in {
    registerAliasedSymbol('?', '__cond',
        ternaryOperator);
}

/* Binary Operators
 ******************************************************************************/
var binary = \op -> let
    xArg = identifier('x', unique()),
    yArg = identifier('y', unique())
in
    setLocals(
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null, xArg),
                ast_pattern.IdentifierPattern.create(null, yArg)]),
            op(xArg, yArg)),
        [getUid xArg, getUid yArg]);

var registerBinary = \op name impl -> {
    registerAliasedSymbol(op, name,
        binary(impl));
};

// Binary Operations
var binaryOp = \op ->
    \x y ->
        ast_expression.BinaryExpression.create(null, op, x, y);

[
    ['+', '__add'],
    ['-', '__sub'],
    ['*', '__mul'],
    ['/', '__div'],
    ['%', '__mod'],
    ['<<', '__blas'],
    ['>>', '__bras'],
    ['>>>', '__brls'],
    ['&', '__band'],
    ['^', '__bxor'],
    ['|', '__bor'],
    ['<', '__lt'],
    ['>', '__gt'],
    ['<=', '__lte'],
    ['>=', '__gte'],
    ['==', '__eq'],
    ['!=', '__neq'],
    ['===', '__seq'],
    ['!==', '__sneq'],
    ['instanceof', '__instanceof'],
    ['||', '__or'],
    ['&&', '__and']
].forEach \ [op name] -> {
    registerBinary(op, name,
        binaryOp(op));
};

// New
registerBinary('new', '__new', \x y ->
    ast_expression.NewExpression.create(null, x, [y]));

// Computed Member
registerBinary('.', '__dot', \x y ->
    ast_expression.MemberExpression.create(null, x, y, true));

// Checked
registerBinary('??', '__chk', \x y ->
    ast_expression.BinaryExpression.create(null, '&&',
        x,
        setUd(
            'id',
            identifier('__x', unique()),
            ast_expression.CallExpression.create(null, x, [y]))));

// Curry
registerBinary('@', '__curry', \x y ->
    ast_expression.CurryExpression.create(null, x, [y]));

// Pipes
with
    pipe = \callee arg ->
        ast_expression.CallExpression.create(null,
            callee,
            [arg])
in {
    registerBinary('<|', '__pipe', pipe);
    registerBinary('|>', '__rpipe', flip pipe);
}

// Compose
with
    singleCompose = \f g -> let
        x = identifier('z', unique())
    in
        setLocals(
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null,
                        x)]),
                ast_expression.CallExpression.create(null,
                    f, [
                        ast_expression.CallExpression.create(null,
                            g,
                            [x])])),
            [getUid x])
in {
    registerBinary('<\\', '__compose', singleCompose);
    registerBinary('\\>', '__rcompose',  flip singleCompose);
}

// ComposeN
with
    multiCompose = \f g -> let
        args = identifier('args', unique())
    in
        setLocals(
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null,
                    ast_pattern.IdentifierPattern.create(null, args),
                    [],
                    null),
                ast_expression.CallExpression.create(null,
                    f, [
                        ast_expression.CallExpression.create(null,
                             ast_expression.MemberExpression.create(null,
                                 g,
                                 identifier('apply')),
                             [ast_value.Literal.create(null, 'null'),
                             args])])),
             [getUid args])
in {
    registerBinary('<<\\', '__composen', multiCompose);
    registerBinary('\\>>', '__rcomposen', flip multiCompose);
}

/* Macro Operators
 ******************************************************************************/
/**
 * Replace the hole in a dot expression with `arg`.
 */
var subDotHole := \expr arg ->
    ?type expr === 'MemberExpression'
        :modify @ expr {
            'object': ?expr.object
                :subDotHole(expr.object, arg)
                :arg
        }
    
    :?type expr === 'CallExpression'
         :modify @ expr { 'callee': subDotHole(expr.callee, arg) }
    
    :expr;

/**
 * Dot Expressoion access.
 */
member := \expr uid -> let
    xArg = identifier('x', uid)
in
    setLocals(
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null, xArg)]),
            subDotHole(expr, xArg)),
        [getUid xArg]);
}
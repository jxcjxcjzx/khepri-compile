/**
 * @fileOverview Khepri builtins.
 */
package builtins
with
    import 'khepri-ast::node' ast_node#{setData setUserData},
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::expression' ast_expression,

    import 'khepri-ast::value' ast_value
in {

var unique = \-> {
    var x = 0;
    return \-> {
        x = x + 1;
        return x;
    };
}();

/* Identifiers
 ******************************************************************************/
builtins = {
    'require': setData(
        new ast_value.Identifier(null, 'require'),
        'uid',
        unique()),
    
    'exports': setData(
        new ast_value.Identifier(null, 'exports'),
        'uid',
        unique()),
    
    'module': setData(
        new ast_value.Identifier(null, 'module'),
        'uid',
        unique())
};
/* Unary Operators
 ******************************************************************************/
var unary = \uid op -> let
    xArg = setData(
        ast_value.Identifier.create(null, 'x'),
        'uid',
        unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null, xArg)]),
        op(xArg));

var unaryOp = \op ->
    unary(unique(), \x ->
        ast_expression.UnaryExpression.create(null, op, x));

[
    ['typeof', '__typeof'],
    ['void', '__void'],
    ['~', '__bnot'],
    ['!', '__lnot'],
    ['++', '__plus'],
    ['--', '__minus']].forEach \ [op name] -> {
        builtins.(op) = unaryOp(op);
    };

/* Binary Operators
 ******************************************************************************/
var binary = \uid flipped op -> let
    xArg = setData(
        ast_value.Identifier.create(null, 'x'),
        'uid',
        unique()),
    
    yArg = setData(
        ast_value.Identifier.create(null, 'y'),
        'uid',
        unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null, xArg),
            ast_pattern.IdentifierPattern.create(null, yArg)]),
        ?flipped
            :op(yArg, xArg)
            :op(xArg, yArg));

var binaryOp = \op flipped ->
    binary(unique(), flipped, \x y ->
        ast_expression.BinaryExpression.create(null, op, x, y));

var logicalOp = \op flipped ->
    binary(unique(), flipped, \x y ->
        ast_expression.LogicalExpression.create(null, op, x, y));

// 
[
    ['+', '__add'],
    ['-', '__sub'],
    ['*', '__mul'],
    ['/', '__div'],
    ['%', '__mod'],
    ['<<', '__blas'],
    ['>>', '__bras'],
    ['>>>', '__brls'],
    ['&', '__band'],
    ['^', '__bxor'],
    ['|', '__bor'],
    ['<', '__lt'],
    ['>', '__gt'],
    ['<=', '__lte'],
    ['>=', '__gte'],
    ['==', '__eq'],
    ['!=', '__neq'],
    ['===', '__seq'],
    ['!==', '__sneq'],
    ['instanceof', '__instanceof']].forEach \ [op name] -> {
        builtins.(op) = binaryOp(op);
        builtins.('_' + op) = binaryOp(op, true);
    };

// Logical
[
    ['||', '__or'],
    ['&&', '__and']].forEach \ [op name] -> {
        builtins.(op) = logicalOp(op);
        builtins.('_' + op) = logicalOp(op, true);
    };

// New
builtins.('new') = binary(unique(), false, \x y ->
    ast_expression.NewExpression.create(null, x, [y]));

builtins.('_new') = binary(unique(), true, \x y ->
    ast_expression.NewExpression.create(null, x, [y]));

// Dot
builtins.('.') = binary(unique(), false, \x y ->
    ast_expression.MemberExpression.create(null, x, y, true));

builtins.('_.') = binary(unique(), true, \x y ->
    ast_expression.MemberExpression.create(null, x, y, true));

// Curry
builtins.('@') = binary(unique(), false, \x y ->
    ast_expression.CurryExpression.create(null, x, y));

builtins.('_@') = binary(unique(), true, \x y ->
    ast_expression.CurryExpression.create(null, x, y));

// Pipes
var pipe = \callee arg ->
    ast_expression.CallExpression.create(null,
        callee,
        [arg]);

builtins.('<|') = builtins.('_|>') = binary(unique(), false, pipe);
builtins.('|>') = builtins.('_<|') = binary(unique(), true, pipe);

// Compose
var identifier = \loc name uid ->
    setData(
        ast_value.Identifier.create(loc, name),
        'uid',
        uid);

var singleCompose = \f, g -> let
    fo = identifier(null, 'f', unique()),
    go = identifier(null, 'g', unique()),
    x = identifier(null, 'x', unique())
in
    ast_expression.CallExpression.create(null,
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null,
                    fo),
                ast_pattern.IdentifierPattern.create(null,
                    go)]),
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null,
                        x)]),
                ast_expression.CallExpression.create(null,
                    fo, [
                        ast_expression.CallExpression.create(null,
                            go,
                            [x])]))),
        [f, g]);

var multiCompose = \f, g -> let
    fo = identifier(null, 'f', unique()),
    go = identifier(null, 'g', unique())
in
    ast_expression.CallExpression.create(null,
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null,
                    fo),
                ast_pattern.IdentifierPattern.create(null,
                    go)]),
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, []),
            ast_expression.CallExpression.create(null,
                fo, [
                    ast_expression.CallExpression.create(null,
                         ast_expression.MemberExpression.create(null,
                             go,
                             identifier(null, 'apply')),
                         [ast_value.Literal.create(null, 'null'),
                         identifier(null, 'arguments')])]))),
        [f, g]);

builtins.('<\\') = builtins.('_\\>') = binary(unique(), false, singleCompose);
builtins.('\\>') = builtins.('_<\\') = binary(unique(), true, singleCompose);


builtins.('<<\\') = builtins.('_\\>>') = binary(unique(), false, multiCompose);
builtins.('\\>>') = builtins.('_<<\\') = binary(unique(), true, multiCompose);



}
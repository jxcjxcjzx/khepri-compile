/**
 * @fileOverview Khepri builtins.
 */
package (
    builtins
    definitions)
with
    import 'khepri-ast::node' ast_node#{setData setUserData},
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::expression' ast_expression,

    import 'khepri-ast::value' ast_value
in {

var unique = (\-> {
    var x = 0;
    return \-> {
        x = x + 1;
        return x;
    };
}());

var identifier = \loc name uid ->
    setData(
        ast_value.Identifier.create(loc, name),
        'uid',
        uid);

definitions = {};

var addSymbol = \name id def -> {
    builtins.(name) = id;
    definitions.(name) = def;
};

var registerAliasedSymbol = \name alias def -> {
    addSymbol(name,
        identifier(null, alias, unique()),
        def);
};

var registerSymbol = \name def ->
    registerAliasedSymbol(name, name, def);

/* Identifiers
 ******************************************************************************/
builtins = {
    'require': setData(
        new ast_value.Identifier(null, 'require'),
        'uid',
        unique()),
    
    'exports': setData(
        new ast_value.Identifier(null, 'exports'),
        'uid',
        unique()),
    
    'module': setData(
        new ast_value.Identifier(null, 'module'),
        'uid',
        unique())
};

/* Unary Operators
 ******************************************************************************/
var unary = \op -> let
    xArg = identifier(null, 'x', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null, xArg)]),
        op(xArg));

var unaryOp = \op ->
    unary\x ->
        ast_expression.UnaryExpression.create(null, op, x);

[
    ['typeof', '__typeof'],
    ['void', '__void'],
    ['~', '__bnot'],
    ['!', '__lnot'],
    ['++', '__plus'],
    ['--', '__minus']
].forEach \ [op name] -> {
    registerAliasedSymbol(op, name,
        unaryOp(op));
};

/* Ternary Operator
 ******************************************************************************/
var ternaryOperator = let
    xArg = identifier(null, 'x', unique()),
    yArg = identifier(null, 'y', unique()),
    zArg = identifier(null, 'z', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null,
                xArg),
            ast_pattern.IdentifierPattern.create(null,
                yArg),
                ast_pattern.IdentifierPattern.create(null,
                zArg)]),
        ast_expression.ConditionalExpression.create(null,
            xArg,
            yArg,
            zArg));

registerAliasedSymbol('?', '__cond',
    ternaryOperator);
    
/* Binary Operators
 ******************************************************************************/
var binary = \flipped op -> let
    xArg = identifier(null, 'x', unique()),
    yArg = identifier(null, 'y', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null, xArg),
            ast_pattern.IdentifierPattern.create(null, yArg)]),
        ?flipped
            :op(yArg, xArg)
            :op(xArg, yArg));

var binaryOp = \op flipped ->
    binary(flipped, \x y ->
        ast_expression.BinaryExpression.create(null, op, x, y));

var logicalOp = \op flipped ->
    binary(flipped, \x y ->
        ast_expression.LogicalExpression.create(null, op, x, y));

// 
[
    ['+', '__add'],
    ['-', '__sub'],
    ['*', '__mul'],
    ['/', '__div'],
    ['%', '__mod'],
    ['<<', '__blas'],
    ['>>', '__bras'],
    ['>>>', '__brls'],
    ['&', '__band'],
    ['^', '__bxor'],
    ['|', '__bor'],
    ['<', '__lt'],
    ['>', '__gt'],
    ['<=', '__lte'],
    ['>=', '__gte'],
    ['==', '__eq'],
    ['!=', '__neq'],
    ['===', '__seq'],
    ['!==', '__sneq'],
    ['instanceof', '__instanceof']
].forEach \ [op name] -> {
    registerAliasedSymbol(op, name,
        binaryOp(op));
    
    registerAliasedSymbol('_' + op, name + 'r',
        binaryOp(op, true));
};

// Logical
[
    ['||', '__or'],
    ['&&', '__and']
].forEach \ [op name] -> {
    registerSymbol(op,
        logicalOp(op));
        
    registerSymbol('_' + op,
        logicalOp(op, true));
};

// New
registerAliasedSymbol('new', '__new', binary(false, \x y ->
    ast_expression.NewExpression.create(null, x, [y])));

registerAliasedSymbol('_new', '__newr', binary(true, \x y ->
    ast_expression.NewExpression.create(null, x, [y])));

// Dot
registerAliasedSymbol('.', '__dot', binary(false, \x y ->
    ast_expression.MemberExpression.create(null, x, y, true)));

registerAliasedSymbol('_.', '__dotr', binary(true, \x y ->
    ast_expression.MemberExpression.create(null, x, y, true)));

// Curry
registerAliasedSymbol('@', '__curry', binary(false, \x y ->
    ast_expression.CurryExpression.create(null, x, [y])));

registerAliasedSymbol('_@', '__curryr', binary(true, \x y ->
    ast_expression.CurryExpression.create(null, x, [y])));

// Pipes
var pipe = \callee arg ->
    ast_expression.CallExpression.create(null,
        callee,
        [arg]);

var lPipe := binary(false, pipe),
    rPipe := binary(true, pipe);

registerAliasedSymbol('<|', '__pipe', lPipe);
registerAliasedSymbol('_|>', '__rpiper', lPipe);

registerAliasedSymbol('|>','__rpipe',  rPipe);
registerAliasedSymbol('_<|', '__piper', rPipe);

// Compose
var singleCompose = \f, g -> let
    fo = identifier(null, 'f', unique()),
    go = identifier(null, 'g', unique()),
    x = identifier(null, 'x', unique())
in
    ast_expression.CallExpression.create(null,
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null,
                    fo),
                ast_pattern.IdentifierPattern.create(null,
                    go)]),
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null,
                        x)]),
                ast_expression.CallExpression.create(null,
                    fo, [
                        ast_expression.CallExpression.create(null,
                            go,
                            [x])]))),
        [f, g]);

var multiCompose = \f, g -> let
    fo = identifier(null, 'f', unique()),
    go = identifier(null, 'g', unique())
in
    ast_expression.CallExpression.create(null,
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null,
                    fo),
                ast_pattern.IdentifierPattern.create(null,
                    go)]),
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, []),
            ast_expression.CallExpression.create(null,
                fo, [
                    ast_expression.CallExpression.create(null,
                         ast_expression.MemberExpression.create(null,
                             go,
                             identifier(null, 'apply')),
                         [ast_value.Literal.create(null, 'null'),
                         identifier(null, 'arguments')])]))),
        [f, g]);

var rCompose := binary(false, singleCompose),
    lCompose := binary(true, singleCompose);

registerAliasedSymbol('<\\', '__compose', rCompose);
registerAliasedSymbol('_\\>', '__rcomposer',  rCompose);

registerAliasedSymbol('\\>', '__rcompose', lCompose);
registerAliasedSymbol('_<\\', '__composer', lCompose);


var rNCompose := binary(false, multiCompose),
    lNCompose :=  binary(true, multiCompose);

registerAliasedSymbol('<<\\', '__composen', rNCompose);
registerAliasedSymbol('_\\>>', '__rcomposenr', rNCompose);

registerAliasedSymbol('\\>>', '__rcomposen', lNCompose);
registerAliasedSymbol('_<<\\', '__composenr', lNCompose);

}
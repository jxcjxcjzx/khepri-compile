/**
 * @fileOverview Khepri builtins.
 */
package (
    builtins
    definitions)
with
    import 'khepri-ast::node' ast_node#{setData setUserData},
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::expression' ast_expression,

    import 'khepri-ast::value' ast_value
in {

var unique = (\-> {
    var x = 0;
    return \-> {
        x = x + 1;
        return x;
    };
}());

var identifier = \loc name uid ->
    setData(
        ast_value.Identifier.create(loc, name),
        'uid',
        uid);

definitions = {};

var addSymbol = \name id def -> {
    builtins.(name) = id;
    definitions.(name) = def;
};

var registerAliasedSymbol = \name alias def -> {
    addSymbol(name,
        identifier(null, alias, unique()),
        def);
};

/* Identifiers
 ******************************************************************************/
builtins = {
    'require': setData(
        new ast_value.Identifier(null, 'require'),
        'uid',
        unique()),
    
    'exports': setData(
        new ast_value.Identifier(null, 'exports'),
        'uid',
        unique()),
    
    'module': setData(
        new ast_value.Identifier(null, 'module'),
        'uid',
        unique())
};

/* Unary Operators
 ******************************************************************************/
with
    unary = \op -> let
        xArg = identifier(null, 'x', unique())
    in
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null, xArg)]),
            op(xArg)),
    
    unaryOp = \op ->
        unary\x ->
            ast_expression.UnaryExpression.create(null, op, x)
in {
    [
        ['typeof', '__typeof'],
        ['void', '__void'],
        ['~', '__bnot'],
        ['!', '__lnot'],
        ['++', '__plus'],
        ['--', '__minus']
    ].forEach \ [op name] -> {
        registerAliasedSymbol(op, name, unaryOp(op));
    };
}

/* Ternary Operator
 ******************************************************************************/
with
    ternaryOperator = let
        xArg = identifier(null, 'x', unique()),
        yArg = identifier(null, 'y', unique()),
        zArg = identifier(null, 'z', unique())
    in
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null,
                    xArg),
                ast_pattern.IdentifierPattern.create(null,
                    yArg),
                    ast_pattern.IdentifierPattern.create(null,
                    zArg)]),
            ast_expression.ConditionalExpression.create(null,
                xArg,
                yArg,
                zArg))
in {
    registerAliasedSymbol('?', '__cond',
        ternaryOperator);
}

/* Binary Operators
 ******************************************************************************/
var binary = \flipped op -> let
    xArg = identifier(null, 'x', unique()),
    yArg = identifier(null, 'y', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null, xArg),
            ast_pattern.IdentifierPattern.create(null, yArg)]),
        ?flipped
            :op(yArg, xArg)
            :op(xArg, yArg));

var binaryOp = \op flipped ->
    binary(flipped, \x y ->
        ast_expression.BinaryExpression.create(null, op, x, y));

var logicalOp = \op flipped ->
    binary(flipped, \x y ->
        ast_expression.LogicalExpression.create(null, op, x, y));

// 
[
    ['+', '__add'],
    ['-', '__sub'],
    ['*', '__mul'],
    ['/', '__div'],
    ['%', '__mod'],
    ['<<', '__blas'],
    ['>>', '__bras'],
    ['>>>', '__brls'],
    ['&', '__band'],
    ['^', '__bxor'],
    ['|', '__bor'],
    ['<', '__lt'],
    ['>', '__gt'],
    ['<=', '__lte'],
    ['>=', '__gte'],
    ['==', '__eq'],
    ['!=', '__neq'],
    ['===', '__seq'],
    ['!==', '__sneq'],
    ['instanceof', '__instanceof']
].forEach \ [op name] -> {
    registerAliasedSymbol(op, name,
        binaryOp(op));
    
    registerAliasedSymbol('_' + op, name + 'r',
        binaryOp(op, true));
};

// Logical
[
    ['||', '__or'],
    ['&&', '__and']
].forEach \ [op name] -> {
    registerAliasedSymbol(op, name,
        logicalOp(op));
        
    registerAliasedSymbol('_' + op, name + 'r',
        logicalOp(op, true));
};

// New
registerAliasedSymbol('new', '__new', binary(false, \x y ->
    ast_expression.NewExpression.create(null, x, [y])));

registerAliasedSymbol('_new', '__newr', binary(true, \x y ->
    ast_expression.NewExpression.create(null, x, [y])));

// Dot
registerAliasedSymbol('.', '__dot', binary(false, \x y ->
    ast_expression.MemberExpression.create(null, x, y, true)));

registerAliasedSymbol('_.', '__dotr', binary(true, \x y ->
    ast_expression.MemberExpression.create(null, x, y, true)));

// Curry
registerAliasedSymbol('@', '__curry', binary(false, \x y ->
    ast_expression.CurryExpression.create(null, x, [y])));

registerAliasedSymbol('_@', '__curryr', binary(true, \x y ->
    ast_expression.CurryExpression.create(null, x, [y])));

// Pipes
var pipe = \callee arg ->
    ast_expression.CallExpression.create(null,
        callee,
        [arg]);

var lPipe := binary(false, pipe),
    rPipe := binary(true, pipe);

registerAliasedSymbol('<|', '__pipe', lPipe);
registerAliasedSymbol('_|>', '__rpiper', lPipe);

registerAliasedSymbol('|>','__rpipe',  rPipe);
registerAliasedSymbol('_<|', '__piper', rPipe);

// Compose
var singleCompose = \f g -> let
    x = identifier(null, 'x', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null,
                x)]),
        ast_expression.CallExpression.create(null,
            f, [
                ast_expression.CallExpression.create(null,
                    g,
                    [x])]));

var multiCompose = \f, g ->
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, []),
        ast_expression.CallExpression.create(null,
            f, [
                ast_expression.CallExpression.create(null,
                     ast_expression.MemberExpression.create(null,
                         g,
                         identifier(null, 'apply')),
                     [ast_value.Literal.create(null, 'null'),
                     identifier(null, 'arguments')])]));


var rCompose := binary(false, singleCompose),
    lCompose := binary(true, singleCompose);

registerAliasedSymbol('<\\', '__compose', rCompose);
registerAliasedSymbol('_\\>', '__rcomposer',  rCompose);

registerAliasedSymbol('\\>', '__rcompose', lCompose);
registerAliasedSymbol('_<\\', '__composer', lCompose);


var rNCompose := binary(false, multiCompose),
    lNCompose :=  binary(true, multiCompose);

registerAliasedSymbol('<<\\', '__composen', rNCompose);
registerAliasedSymbol('_\\>>', '__rcomposenr', rNCompose);

registerAliasedSymbol('\\>>', '__rcomposen', lNCompose);
registerAliasedSymbol('_<<\\', '__composenr', lNCompose);

}
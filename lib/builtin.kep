/**
 * @fileOverview Khepri builtins.
 */
package (
    builtins
    definitions)
with
    import 'khepri-ast::node' ast_node#{setData setUserData},
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::expression' ast_expression,

    import 'khepri-ast::value' ast_value
in {

var flip := \f -> \x y -> f(y, x);

var unique = (\-> {
    var x = 0;
    return \-> {
        x = x + 1;
        return x;
    };
}());

var identifier = \name uid ->
    setData(
        ast_value.Identifier.create(null, name),
        'uid',
        uid);

/* Exports
 ******************************************************************************/
definitions = {};
builtins = {};

var addSymbol = \name id def -> {
    builtins.(name) = id;
    definitions.(name) = def;
};

var registerAliasedSymbol = \name alias def -> {
    addSymbol(name,
        identifier(alias, unique()),
        def);
};

/* Reserved Identifiers
 ******************************************************************************/
builtins.('require') = identifier('require', unique());
builtins.('exports') = identifier('exports', unique());
builtins.('module') = identifier('module', unique());

/* Unary Operators
 ******************************************************************************/
with
    unary = \op -> let
        xArg = identifier('x', unique())
    in
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null, xArg)]),
            op(xArg)),
    
    unaryOp = \op ->
        unary\x ->
            ast_expression.UnaryExpression.create(null, op, x)
in {
    [
        ['typeof', '__typeof'],
        ['void', '__void'],
        ['~', '__bnot'],
        ['!', '__lnot'],
        ['++', '__plus'],
        ['--', '__minus']
    ].forEach \ [op name] -> {
        registerAliasedSymbol(op, name, unaryOp(op));
    };
}

/* Ternary Operator
 ******************************************************************************/
with
    ternaryOperator = let
        xArg = identifier('x', unique()),
        yArg = identifier('y', unique()),
        zArg = identifier('z', unique())
    in
        ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null, [
                ast_pattern.IdentifierPattern.create(null,
                    xArg),
                ast_pattern.IdentifierPattern.create(null,
                    yArg),
                    ast_pattern.IdentifierPattern.create(null,
                    zArg)]),
            ast_expression.ConditionalExpression.create(null,
                xArg,
                yArg,
                zArg))
in {
    registerAliasedSymbol('?', '__cond',
        ternaryOperator);
}

/* Binary Operators
 ******************************************************************************/
var binary = \flipped op -> let
    xArg = identifier('x', unique()),
    yArg = identifier('y', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null, xArg),
            ast_pattern.IdentifierPattern.create(null, yArg)]),
        ?flipped
            :op(yArg, xArg)
            :op(xArg, yArg));

var registerBinary = \op name impl -> {
    registerAliasedSymbol(op, name,
        binary(false, impl));
    
    registerAliasedSymbol('_' + op, name + 'r',
        binary(true, impl));
};

// Binary Operations
var binaryOp = \op ->
    \x y ->
        ast_expression.BinaryExpression.create(null, op, x, y);

[
    ['+', '__add'],
    ['-', '__sub'],
    ['*', '__mul'],
    ['/', '__div'],
    ['%', '__mod'],
    ['<<', '__blas'],
    ['>>', '__bras'],
    ['>>>', '__brls'],
    ['&', '__band'],
    ['^', '__bxor'],
    ['|', '__bor'],
    ['<', '__lt'],
    ['>', '__gt'],
    ['<=', '__lte'],
    ['>=', '__gte'],
    ['==', '__eq'],
    ['!=', '__neq'],
    ['===', '__seq'],
    ['!==', '__sneq'],
    ['instanceof', '__instanceof']
].forEach \ [op name] -> {
    registerBinary(op, name,
        binaryOp(op));
};

// Logical
with
    logicalOp = \op ->
        \x y ->
            ast_expression.LogicalExpression.create(null, op, x, y)
in {
    [
        ['||', '__or'],
        ['&&', '__and']
    ].forEach \ [op name] -> {
        registerBinary(op, name,
            logicalOp(op));
    };
}

// New
registerBinary('new', '__new', \x y ->
    ast_expression.NewExpression.create(null, x, [y]));

// Dot
registerBinary('.', '__dot', \x y ->
    ast_expression.MemberExpression.create(null, x, y, true));

// Curry
registerBinary('@', '__curry', \x y ->
    ast_expression.CurryExpression.create(null, x, [y]));

// Pipes
with
    pipe = \callee arg ->
        ast_expression.CallExpression.create(null,
            callee,
            [arg])
in {
    registerBinary('<|', '__pipe', pipe);
    registerBinary('|>', '__pipe', flip pipe);
}

// Compose
var singleCompose = \f g -> let
    x = identifier('x', unique())
in
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, [
            ast_pattern.IdentifierPattern.create(null,
                x)]),
        ast_expression.CallExpression.create(null,
            f, [
                ast_expression.CallExpression.create(null,
                    g,
                    [x])]));

var multiCompose = \f, g ->
    ast_expression.FunctionExpression.create(null, null,
        ast_pattern.ArgumentsPattern.create(null, null, []),
        ast_expression.CallExpression.create(null,
            f, [
                ast_expression.CallExpression.create(null,
                     ast_expression.MemberExpression.create(null,
                         g,
                         identifier('apply')),
                     [ast_value.Literal.create(null, 'null'),
                     identifier('arguments')])]));


registerBinary('<\\', '__compose', singleCompose);
registerAliasedSymbol('\\>', '__rcompose',  flip singleCompose);

registerBinary('<<\\', '__composen', multiCompose);
registerBinary('\\>>', '__rcomposen', flip multiCompose);

}
package (
    expandCallee
    expandCurry)
with
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,

    import '../ast' {
        getUid},
    import '../fun' {
        concat
        map},
    import './rename' {rename},
    import '../builtin' {builtins}
in{

/**
 * Convert the elements of an argument unpack object to a set of bindings.
 */
var argsToBindings := \uid parameters args ->
    map(
        \x i ->
            ast_declaration.Binding.create(null,
                rename(uid, [], x),
                (args.(i) || builtins.undefined)),
        parameters.elements);

/**
 * Convert the arguments unpack of an arguments unpack to a binding.
 */
var argsBinding := \uid arg bindings args ->
    ast_declaration.Binding.create(null,
        rename(uid, [], arg),
        ast_expression.ArrayExpression.create(null,
            args.map \ x i ->
                ?bindings.(i)
                    :bindings.(i).pattern.id
                    :x));

/* Interface
 ******************************************************************************/
/**
 * Expand a call of a lambda expression of let expression with lambda body
 * to a let expression.
 */
expandCallee = \uid callee args -> let
    target = ?callee.type === 'LetExpression' : callee.body : callee,
    
    closure = ((target.ud && target.ud.closure) || []),
    
    bindings = argsToBindings(uid, target.params, args),
    
    argBinding = ?target.params.id
        :argsBinding(uid, target.params.id, bindings, args)
        :[]
in
    ast_expression.LetExpression.create(null,
        concat(
            callee.bindings || [],
            bindings,
            argBinding),
        rename(uid, closure, target.body));

/**
 * Expand a curry of a lambda expression of let expression with curry body
 * to a let expression.
 */
expandCurry = \uid base args -> let
    target = ?base.type === 'LetExpression' : base.body : base
in
    ?!target.params.elements.length
        :base
    :let
        first = target.params.elements.(0),
        rest = target.params.elements.slice(1),
        
        closure = ((target.ud && target.ud.closure) || []),
        
        body = ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null,
                rest,
                target.params.self),
            rename(uid, map, target.body))
    in
        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
            :ast_expression.LetExpression.create(null,
                concat(
                    base.bindings || [],
                    ast_declaration.Binding.create(null,
                        rename(uid, closure, first),
                        args.(0))),
                body)
            :body;

}
package (
    getLocals
    rename
    incCount)
with
    import 'khepri-ast-zipper' {khepriZipper},
    import 'neith::walk' {preWalk},

    import 'neith::tree' tree,
    
    import 'khepri-ast::node' {setData},
    
    import '../fun' {
        contains},
    import '../ast' {
        type
        tryGetUd
        getUd
        getUid
        setUid},
    import './expansion' {
        incrementCount}
in {

var prefixUid := \prefix uid ->
    prefix + '-' + uid;

getLocals := \node prefix ->
     tryGetUd([], 'locals', node).map(prefixUid @ prefix);

var updateClosure = \node prefix list -> let
    closure = tryGetUd([], 'locals', node),
    
    closure = closure.map \ x ->
        ?contains(list, x)
            :prefixUid(prefix, x)
            :x
in
    setData(node, 'locals', closure);


/*
 ******************************************************************************/
/**
 * Rename all identifier instances in an AST.
 * 
 * @param prefix Unique id to prefix to all renamed identifiers.
 * @param list List of identifier uids to rename. All others will be ignored
 * @param root Root node of tree to traverse.
 */ 
rename = \prefix list root ->
    tree.node <| preWalk(
        \ctx -> let
            node = tree.node(ctx),
            uid = getUid(node)
        in
            ?contains(list, uid)
                :tree.setNode(
                    setUid(prefixUid(prefix, uid), node),
                    ctx)
            
            :?type node === 'FunctionExpression'
                :tree.setNode(
                    updateClosure(node, prefix, list),
                    ctx)
            
            :ctx,
        khepriZipper root);

/**
 * 
 */
incCount = \target count value root ->
    tree.node <| preWalk(
        \ctx -> let
            node = tree.node(ctx),
            uid = getUid(node)
        in
            ?node && target === uid
                :tree.setNode(
                    incrementCount(node, count, value),
                    ctx)
                :ctx,
        khepriZipper root);

}

package (
    rename
    incCount)
with
    import 'khepri-ast-zipper' {khepriZipper},
    import 'neith::walk' {preWalk},

    import 'neith::tree' tree,
    
    import 'khepri-ast::node' {setData},
    
    import '../ast' {type getUid}
in {

var updateClosure = \node prefix list -> let
    closure = (node.ud && node.ud.closure) || [],
    
    closure = closure.map \ x ->
        ?list.indexOf(x) >= 0
            :prefix + '-' + x
            :x
in
    setData(node, 'closure', closure);

/**
 * Rename all identifier instances in an AST.
 * 
 * @param prefix Unique id to prefix to all renamed identifiers.
 * @param list List of identifier uids to rename. All others will be ignored
 * @param root Root node of tree to traverse.
 */ 
rename = \prefix list root ->
    tree.node <| preWalk(
        \ctx -> let
            node = tree.node(ctx),
            uid = getUid(node)
        in
            ?uid && list.indexOf(uid) >= 0
                :tree.setNode(
                    setData(node, 'uid', prefix + '-' + uid),
                    ctx)
            
            :?type node === 'FunctionExpression'
                :tree.setNode(
                    updateClosure(node, prefix, list),
                    ctx)
            
            :ctx,
        khepriZipper root);

/**
 */
incCount = \target count value root ->
    tree.node <| preWalk(
        \ctx -> {with
            node = tree.node(ctx),
            uid = getUid(node),
            exp = node && node.ud && node.ud.expand
        in {
            if (target && node && target === uid) {
                return tree.setNode(
                    setData(node, 'expand', {'count': ((exp && exp.count) || count) + 1, 'value': value}),
                    ctx);
            }
            return ctx;
        }},
        khepriZipper root);

}

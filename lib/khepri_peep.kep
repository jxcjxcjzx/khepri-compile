/**
 * @fileOverview Khepri peephole optimization.
 */
package (
    optimize)
with
    import 'hashtrie' hashtrie,
    
    import 'khepri-ast-zipper' {khepriZipper},
    import 'neith::walk' {'walk': neithWalk},
    import 'neith::tree' tree,

    import 'khepri-ast::node' {Node setUserData setData},
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    
    import 'akh::base' {
        next
        'sequence': seq
        'sequencea': seqa},
    
    import 'akh::unique' Unique,
    import 'akh::trans::state' StateT,

    import 'zipper-m::trans::zipper' ZipperT,
    import 'zipper-m::walk' walk,
    
    import './builtin' builtins,
    import './fun' fun,
    import './unpack' innerPattern
in {

/* Operations
 ******************************************************************************/
var M = ZipperT (StateT Unique);

var run = \c ctx seed ->
    Unique.runUnique(
        StateT.evalStateT(
            ZipperT.runZipperT(c, ctx),
            hashtrie.empty),
        seed);

var pass = M.of null;

var node =  M.node;

var modify = M.modifyNode;
var set = M.setNode;

var unique = M.liftInner (Unique.unique);

var addBinding = \uid target ->
    M.lift <| M.inner.modify(\bindings ->
        hashtrie.set(uid, target, bindings));

var getBinding = \uid ->
    M.lift(M.inner.get).map(\bindings ->
        hashtrie.get(uid, bindings));
/*
 ******************************************************************************/
var peepholes = {};

var addPeephole = \types, up, condition, f -> {
    var entry = {
        'condition': condition,
        'map': f,
        'up': up
    };
    
    types.forEach \ type -> {
        peepholes.(type) = ?peepholes.(type)
            :fun.concat(peepholes.(type), entry)
            :[entry];
    };
};

var rewrite = \base list root ->
    neithWalk(
        \ctx -> let node = tree.node(ctx) in
            ?node.ud && node.ud.uid && list.indexOf(node.ud.uid) !== --1
                :tree.modifyNode(\node ->
                    setData(node, 'uid', base + '-' + node.ud.uid), ctx)
                :ctx,
        \x -> x,
        khepriZipper(root))
            |> tree.node;

/* Constant Folding
 ******************************************************************************/
var isPrimitive = \node ->
    node.type === 'Literal' && (
        node.kind === 'string'
        || node.kind === 'number'
        || node.kind === 'boolean'
        || node.kind === 'null');

var isTruthy = \node ->
    (  isPrimitive node 
    && !!node.value);

/**
 * Combine binary arithmetic operations on primitive literals
 */
let
    arithmetic = {
        '+': (+),
        '-': (-),
        '*': (*),
        '/': (/),
        '%': ('%'),
        '<<': (<<),
        '>>': (>>),
        '>>>': (>>>),
        '<': (<),
        '>': (>),
        '<=': (<=),
        '>=': (>=),
        '||': (||),
        '&&': (&&)}
in
    addPeephole(['BinaryExpression', 'LogicalExpression'], true,
        \{operator left right} ->
            arithmetic.(operator)
            && isPrimitive(left)
            && isPrimitive(right),
        
        modify \ {operator left right} -> let
            value = arithmetic.(operator)(left.value, right.value)
        in
            ast_value.Literal.create(null, typeof value, value));

/**
 * Combine simple unary operations on primitive literals
 */
let
    arithmetic = {
        '!': (!),
        '~': (~),
        'typeof': (typeof),
        '+': (++),
        '-': (--)}
in
    addPeephole(['UnaryExpression'], true,
        \{operator argument} ->
            arithmetic.(operator)
            && isPrimitive(argument),
        
        modify \ {operator argument} -> let
            value = arithmetic.(operator)(argument.value)
        in
            ast_value.Literal.create(null, typeof value, value));

/**
 * Reduce if statements with simple test.
 */
addPeephole(['IfStatement'], true,
    \node ->
        isPrimitive node.test,
    
    modify \ {test consequent alternate} ->
        ?isTruthy test
            :consequent
            :alternate);

/**
 * Reduce ternary expression with simple test.
 */
addPeephole(['ConditionalExpression'], true,
    \node ->
        isPrimitive node.test,
    
    modify \ {test consequent alternate} ->
        ?isTruthy test
            :consequent
            :alternate);

/* Constant Propagation
 ******************************************************************************/
/**
 */
addPeephole(['VariableDeclarator'], true,
    \node ->
        (  node.immutable
        && node.init
        && (  (node.init.type === 'Identifier' && node.init.ud.uid !== node.id.ud.uid)
           || isPrimitive node.init
           || node.init.type === 'FunctionExpression')),
    
    node.chain \ node ->
        seq(
            addBinding(node.id.ud.uid, node.init)));

/**
 * 
 */
addPeephole(['Binding'], true,
    \node ->
        (node.pattern.type === 'IdentifierPattern'
        && (  (node.value.type === 'Identifier' && node.value.ud.uid !== node.pattern.id.ud.uid)
           || isPrimitive node.value)),
    
    node.chain \ node ->
        seq(
            addBinding(node.pattern.id.ud.uid, node.value),
            set(null)));

/**
 */
addPeephole(['Identifier'], true,
    \node -> node.ud && node.ud.uid,
    
    node.chain \ node ->
    getBinding(node.ud.uid).chain \ binding ->
        ?binding && binding.type !== 'FunctionExpression'
            :set(binding)
            :pass);

/* Constant Propagation
 ******************************************************************************/
/*addPeephole(['Binding'], true,
    \node ->
        (node.pattern.type !== 'IdentifierPattern'),
    
    modify \ node ->
        innerPattern(node.value, node.pattern));
*/

addPeephole(['LetExpression'], true,
    \node -> true,
    
    modify \ node ->
        ast_expression.LetExpression.create(null,
            fun.flatten <| node.bindings,
            node.body));


addPeephole(['CallExpression'], false,
    \node ->
        (node.callee.type === 'Identifier'),
    
    node.chain \ node ->
    getBinding(node.callee.ud.uid).chain \ binding ->
        ?binding
            :modify \ node ->
                ast_expression.CallExpression.create(null,
                    binding,
                    node.args)
            :pass);
            

addPeephole(['CallExpression'], false,
    \node ->
        (  node.callee.type === 'FunctionExpression'
        && node.callee.body.type !== 'BlockStatement'
        && !node.callee.params.self),
    
    unique.chain \ uid ->
    modify \ node -> let
        bindings =
            node.callee.params.elements.map \ x i ->
                ast_declaration.Binding.create(null,
                    x,
                    ?node.args.(i)
                        :node.args.(i)
                        :ast_value.Identifier.create(null, 'undefined'))
    in
        rewrite(uid, bindings.map(\x -> x.pattern.id.ud.uid),
            ast_expression.LetExpression.create(null,
                bindings,
                node.callee.body)));

/* Peepholes
 ******************************************************************************/
/**
 * Rewrite `return let` to a with statement.
 */
addPeephole(['ReturnStatement'], false,
    \node ->
        (node.argument && node.argument.type === 'LetExpression'),
    modify\node ->
        ast_statement.WithStatement.create(null,
            node.argument.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ReturnStatement.create(node.loc, node.argument.body)])));

/**
 * Rewrite `\...-> let` to a with statement.
 */
addPeephole(['FunctionExpression'], false,
    \node ->
        (node.body.type === 'LetExpression'),
    modify\node ->
        ast_expression.FunctionExpression.create(null,
            node.id,
            node.params,
            ast_statement.BlockStatement.create(null, [
                ast_statement.WithStatement.create(null,
                    node.body.bindings,
                    ast_statement.BlockStatement.create(null, 
                        [ast_statement.ReturnStatement.create(node.loc, node.body.body)]))])));

/**
 * Rewrite top level let expressions to with statements.
 */
addPeephole(['ExpressionStatement'], true,
    \node ->
        (node.expression && node.expression.type === 'LetExpression'),
    modify\node ->
        ast_statement.WithStatement.create(null,
            node.expression.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc, node.expression.body)])));

/**
 * Rewrite top level let expressions to with statements.
 */
addPeephole(['ExpressionStatement'], true,
    \node ->
        (  node.expression
        && node.expression.type === 'AssignmentExpression'
        && node.expression.right.type === 'LetExpression'),
    modify\node ->
        ast_statement.WithStatement.create(null,
            node.expression.right.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc,
                    ast_expression.AssignmentExpression.create(node.expression.loc, node.expression.operator,
                        node.expression.left,
                        node.expression.right.body))])));

/**
 * Flatten let with let body.
 */
addPeephole(['LetExpression'], true,
    \node ->
        node.body.type === 'LetExpression',
    modify\node ->
        ast_expression.LetExpression.create(null,
            fun.concat(
                node.bindings,
                node.body.bindings),
            node.body.body));

/**
 * Convert Unary Op Expression to function.
 * 
 * TODO: Should not be in this stage
 */
addPeephole(['UnaryOperatorExpression'], true,
    \_ -> true,
    unique.chain \ xUid ->
        modify\node -> let
            arg = setData(
                ast_value.Identifier.create(null, 'x'),
                'uid',
                xUid)
        in
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null, arg)]),
                ast_expression.UnaryExpression.create(null,
                    node.op,
                    arg)));

/**
 * Convert binary op expression to function.
 * 
 * TODO: Should not be in this stage
 */
addPeephole(['BinaryOperatorExpression'], true,
    \_ -> true,
    
    unique.chain \ xUid ->
    unique.chain \ yUid ->
        modify \ node -> let
            xArg = setData(
                ast_value.Identifier.create(null, 'x'),
                'uid',
                xUid),
            
            yArg = setData(
                ast_value.Identifier.create(null, 'y'),
                'uid',
                yUid),
            
            kind =
                ?node.op === '||' || node.op === '&&'
                    :ast_expression.LogicalExpression.create
                :?node.op === '.'
                    :\loc _ x y -> ast_expression.MemberExpression.create(loc, x, y, true)
                :?node.op === '@'
                    :\loc _ x y -> ast_expression.CurryExpression.create(loc, x, y)
                :?node.op === 'new'
                    :\loc _ x y -> ast_expression.NewExpression.create(loc, x, [y])
                :ast_expression.BinaryExpression.create
        in
            
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null, xArg),
                    ast_pattern.IdentifierPattern.create(null, yArg)]),
                ?node.flipped
                    :kind(null, node.op, yArg, xArg)
                    :kind(null, node.op, xArg, yArg)));

/**
 * Convert curry on function expression to function.
 * 
 * Note that this discards arguments that are not used.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        node.base.type === 'FunctionExpression'
        && !node.base.params.id, // make sure no one is using arguments object
    
    modify\node -> let
        first = node.base.params.elements.(0),
        rest = node.base.params.elements.slice(1),
        
        body = ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null,
                rest,
                node.base.params.self),
            node.base.body)
    in
        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
            :ast_expression.LetExpression.create(null,
                [ast_declaration.Binding.create(null,
                    first,
                    node.args.(0))],
                body)
            :body);

/**
 * Try Convert curry on let with function body to function.
 * 
 * Note that this may discard arguments that are not used.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        node.base.type === 'LetExpression'
        && node.base.body.type === 'FunctionExpression'
        && !node.base.body.params.id, // make sure no one is using arguments object
    
    modify\node -> let
        first = node.base.body.params.elements.(0),
        rest = node.base.body.params.elements.slice(1),
        
        body = ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null,
                rest,
                node.base.body.params.self),
            node.base.body.body)
    in
        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
            :ast_expression.LetExpression.create(null,
                fun.concat(
                    node.base.bindings,
                    ast_declaration.Binding.create(null,
                        first,
                        node.args.(0))),
                body)
            :ast_expression.LetExpression.create(null,
                node.base.bindings,
                body));

/**
 * Flatten curry of curry.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        node.base.type === 'CurryExpression',
    modify\node ->
        ast_expression.CurryExpression.create(null,
            node.base.base,
            fun.concat(
                node.base.args,
                node.args)));

/**
 * Rewrite left pipe of curried expression to a call.
 */
addPeephole(['BinaryExpression'], true,
    \node ->
        (node.operator === '|>' && node.right.type === 'CurryExpression'),
    modify\node ->
        ast_expression.CallExpression.create(null,
            node.right.base,
            fun.concat(
                node.right.args || [],
                node.left)));

/**
 * Rewrite right pipe of curried expression to a call.
 */
addPeephole(['BinaryExpression'], true,
    \{operator left} ->
        (operator === '<|' && left.type === 'CurryExpression'),
    
    modify\node ->
        ast_expression.CallExpression.create(null,
            node.left.base,
            fun.concat(
                node.left.args || [],
                node.right)));

/**
 * Rewrite call of curried expression to a call direct call on curry base.
 */
addPeephole(['CallExpression'], true,
    \{callee} ->
        callee.type ==='CurryExpression',
    
    modify\node ->
        ast_expression.CallExpression.create(null,
            node.callee.base,
            fun.concat(
                node.callee.args || [],
                node.args)));


/* Interface
 ******************************************************************************/
var upTransforms = \node -> 
    ((node && peepholes.(node.type)) || [])
        .filter(\x -> x.up && x.condition(node));

var downTransforms = \node -> 
    ((node && peepholes.(node.type)) || [])
        .filter(\x -> !x.up && x.condition(node));

var transform = \node transforms ->
    ?transforms.length
        :seqa(transforms.map(\x -> x.map))
        :pass;

var _transform = node.chain \ node -> let
    t = downTransforms node
in
    ?t.length
        :next(transform(node, [t.(0)]), _transform)
        :pass;

var _transformPost = node.chain \ node ->
    transform(node, upTransforms node);

/**
 * 
 */
optimize = \ast data ->
    run(
        next(
            walk(M, _transform, _transformPost),
            node),
        khepriZipper(ast),
        data.unique);

}

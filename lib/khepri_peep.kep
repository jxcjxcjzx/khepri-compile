/**
 * @fileOverview Khepri peephole optimization.
 * 
 * Rewrites Khepri to forms that can be more transformed into more efficient
 * Javascript.
 */
package (
    optimize)
with
    import 'khepri-ast-zipper' {khepriZipper},

    import 'khepri-ast::node' {Node setUserData setData},
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::value' ast_value,

    
    import './fun' fun,
    import './rewritter' {
        UP
        DOWN
        Rewritter
        rewrite}
in {

var peepholes = new Rewritter();

/* Binding Expression Normalization
 ******************************************************************************/
/**s
 * Flatten variable declaration declaration lists and remove if declaration list
 * is empty.
 */
peepholes.add(['VariableDeclaration'], true,
    \_ -> true,
    
    \{declarations} ->
        let bound = fun.flattenr <| declarations in
            ?bound.length
                :ast_declaration.VariableDeclaration.create(null, bound)
                :null);

/**
 * Flatten let expression bindings lists and collapse to body 
 * when binding list is empty
 */
peepholes.add(['LetExpression'], true,
    \_ -> true,
    
    \{bindings body} ->
        let bound = fun.flattenr <| bindings in
            ?bound.length
                :ast_expression.LetExpression.create(null, bound, body)
                :body);

/**
 * Flatten with statement bindings lists and collapse to body 
 * when binding list is empty.
 */
peepholes.add(['WithStatement'], true,
    \_ -> true,
    
    \{bindings body} ->
        let bound = fun.flattenr <| bindings in
            ?bound.length
                :ast_statement.WithStatement.create(null, bound, body)
                :body);

/* Flattening
 ******************************************************************************/
/**
 * Flatten let with let body.
 */
peepholes.add(['LetExpression'], true,
    \node ->
        node.body.type === 'LetExpression',
    \node ->
        ?node.body.type === 'LetExpression'
            :ast_expression.LetExpression.create(null,
                fun.concat(
                    node.bindings,
                    node.body.bindings),
                node.body.body)
            :node);

/**
 * Flatten curry of curry.
 */
peepholes.add(['CurryExpression'], true,
    \node ->
        node.base.type === 'CurryExpression',
    \node ->
        ast_expression.CurryExpression.create(null,
            node.base.base,
            fun.concat(
                node.base.args,
                node.args)));

/* Let to With Statement Rewrites
 ******************************************************************************/
/**
 * Rewrite `return let` to a with statement.
 */
peepholes.add(['ReturnStatement'], false,
    \node ->
        (node.argument && node.argument.type === 'LetExpression'),
    \node ->
        ast_statement.WithStatement.create(null,
            node.argument.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ReturnStatement.create(node.loc, node.argument.body)])));

/**
 * Rewrite `\...-> let` to a with statement.
 */
peepholes.add(['FunctionExpression'], false,
    \node ->
        (node.body.type === 'LetExpression'),
    \node ->
        ast_expression.FunctionExpression.create(null,
            node.id,
            node.params,
            ast_statement.BlockStatement.create(null, [
                ast_statement.WithStatement.create(null,
                    node.body.bindings,
                    ast_statement.BlockStatement.create(null, 
                        [ast_statement.ReturnStatement.create(node.loc, node.body.body)]))])));

/**
 * Rewrite top level let expressions to with statements.
 */
peepholes.add(['ExpressionStatement'], true,
    \node ->
        (node.expression && node.expression.type === 'LetExpression'),
    \node ->
        ast_statement.WithStatement.create(null,
            node.expression.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc, node.expression.body)])));

/**
 * Rewrite top level let expressions to with statements.
 */
peepholes.add(['ExpressionStatement'], true,
    \node ->
        (  node.expression
        && node.expression.type === 'AssignmentExpression'
        && node.expression.right.type === 'LetExpression'),
    \node ->
        ast_statement.WithStatement.create(null,
            node.expression.right.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc,
                    ast_expression.AssignmentExpression.create(node.expression.loc, node.expression.operator,
                        node.expression.left,
                        node.expression.right.body))])));

/* Interface
 ******************************************************************************/
/**
 * 
 */
optimize = \ast data ->
    rewrite(peepholes, khepriZipper(ast));

}

/**
 * 
 */
package (
    optimize)
with
    import 'bes::record' record,

    import 'neith::tree' tree#{modifyNode},
    import 'neith::zipper' zipper,

    import 'khepri-ast-zipper' {khepriZipper},
    
    import 'khepri-ast::node' {Node setUserData setData},
    import 'khepri-ast::declaration' ast_declaration,
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    
    import 'akh::state' StateM,
    
    import './fun' fun,
    import './tail' {Tail trampoline}
in {

/* State
 ******************************************************************************/
var State = record.declare(null, [
    'ctx',
    'unique']);

var run = StateM.evalState;

var bind = StateM.chain;

var pass = StateM.of null;

var binary = \a b f ->
    a.chain \x ->
    b.chain \y ->
    f(x, y);

var next = \p c ->
    p.chain(fun.constant c);

var seqa = \arr -> fun.reduce(arr, next);
var seq = \args(...) -> seqa(args);

var modifyState = \f -> StateM.get.chain(\s -> StateM.put(f(s)));

static console;

var get = \op ->
    StateM.get.map(\s -> op <| s.ctx);

var node = get tree.node;

var move = \op ->
    modifyState \ s ->
        State.setCtx(s, op(s.ctx));

var modify = \f ->
    move tree.modifyNode@f;

var ctx = StateM.get.map(\s -> s.ctx);

var unique = StateM.get
    .chain\x ->
        next(
            StateM.get.chain \ s -> StateM.put <| s.setUnique(s.unique + 1)
            StateM.of(x));
/*
 ******************************************************************************/
var peepholes = {};

var addPeephole = \types, up, condition, f -> {
    var entry = {
        'condition': condition,
        'map': f,
        'up': up
    };
    
    types.forEach <|\ type -> {
        peepholes.(type) = ?peepholes.(type)
            :fun.concat(peepholes.(type), entry)
            :[entry];
    };
};

/* Peepholes
 ******************************************************************************/
/**
 * Rewrite `return let` to a with statement.
 */
addPeephole(['ReturnStatement'], false,
    \node ->
        (node.argument && node.argument.type === 'LetExpression'),
    modify\node ->
        ast_statement.WithStatement.create(null,
            node.argument.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ReturnStatement.create(node.loc, node.argument.body)])));

/**
 * Rewrite `\...-> let` to a with statement.
 */
addPeephole(['FunctionExpression'], false,
    \node ->
        (node.body.type === 'LetExpression'),
    modify\node ->
        ast_expression.FunctionExpression.create(null,
            node.id,
            node.params,
            ast_statement.BlockStatement.create(null, [
                ast_statement.WithStatement.create(null,
                    node.body.bindings,
                    ast_statement.BlockStatement.create(null, 
                        [ast_statement.ReturnStatement.create(node.loc, node.body.body)]))])));

/**
 * Rewrite top level let expressions to with statements.
 */
addPeephole(['ExpressionStatement'], true,
    \node ->
        (node.expression && node.expression.type === 'LetExpression'),
    modify\node ->
        ast_statement.WithStatement.create(null,
            node.expression.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc, node.expression.body)])));

/**
 * Rewrite top level let expressions to with statements.
 */
addPeephole(['ExpressionStatement'], true,
    \node ->
        (  node.expression
        && node.expression.type === 'AssignmentExpression'
        && node.expression.right.type === 'LetExpression'),
    modify\node ->
        ast_statement.WithStatement.create(null,
            node.expression.right.bindings,
            ast_statement.BlockStatement.create(null, 
                [ast_statement.ExpressionStatement.create(node.loc,
                    ast_expression.AssignmentExpression.create(node.expression.loc, node.expression.operator,
                        node.expression.left,
                        node.expression.right.body))])));

/**
 * Flatten let with let body.
 */
addPeephole(['LetExpression'], true,
    \node ->
        node.body.type === 'LetExpression',
    modify\node ->
        ast_expression.LetExpression.create(null,
            fun.concat(
                node.bindings,
                node.body.bindings),
            node.body.body));

/**
 * Convert Unary Op Expression to function.
 */
addPeephole(['UnaryOperatorExpression'], true,
    \_ -> true,
    bind(unique, \xUid ->
        modify\node -> let
            arg = setData(
                ast_value.Identifier.create(null, 'x'),
                'uid',
                xUid)
        in
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null, arg)]),
                ast_expression.UnaryExpression.create(null,
                    node.op,
                    arg))));

/**
 * Convert binary op expression to function.
 */
addPeephole(['BinaryOperatorExpression'], true,
    \_ -> true,
    
    binary(unique, unique, \xUid yUid ->
        modify\node -> let
            xArg = setData(
                ast_value.Identifier.create(null, 'x'),
                'uid',
                xUid),
            
            yArg = setData(
                ast_value.Identifier.create(null, 'y'),
                'uid',
                yUid),
            
            kind =
                ?node.op === '||' || node.op === '&&'
                    :ast_expression.LogicalExpression.create
                :?node.op === '.'
                    :\loc _ x y -> ast_expression.MemberExpression.create(loc, x, y, true)
                :ast_expression.BinaryExpression.create
        in
            ast_expression.FunctionExpression.create(null, null,
                ast_pattern.ArgumentsPattern.create(null, null, [
                    ast_pattern.IdentifierPattern.create(null, xArg),
                    ast_pattern.IdentifierPattern.create(null, yArg)]),
                kind(null,
                    node.op,
                    xArg,
                    yArg))));

/**
 * Convert curry on function expression to function.
 * 
 * Note that this discards arguments that are not used.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        node.base.type === 'FunctionExpression'
        && !node.base.params.id, // make sure no one is using arguments object
    
    modify\node -> let
        first = node.base.params.elements.(0),
        rest = node.base.params.elements.slice(1),
        
        body = ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null,
                rest,
                node.base.params.self),
            node.base.body)
    in
        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
            :ast_expression.LetExpression.create(null,
                [ast_declaration.Binding.create(null,
                    first,
                    node.args.(0))],
                body)
            :body);

/**
 * Try Convert curry on let with function body to function.
 * 
 * Note that this may discard arguments that are not used.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        node.base.type === 'LetExpression'
        && node.base.body.type === 'FunctionExpression'
        && !node.base.body.params.id, // make sure no one is using arguments object
    
    modify\node -> let
        first = node.base.body.params.elements.(0),
        rest = node.base.body.params.elements.slice(1),
        
        body = ast_expression.FunctionExpression.create(null, null,
            ast_pattern.ArgumentsPattern.create(null, null,
                rest,
                node.base.body.params.self),
            node.base.body.body)
    in
        ?first && (first.type === 'IdentifierPattern' || first.type === 'AsPattern' || first.type === 'ObjectPattern')
            :ast_expression.LetExpression.create(null,
                fun.concat(
                    node.base.bindings,
                    ast_declaration.Binding.create(null,
                        first,
                        node.args.(0))),
                body)
            :ast_expression.LetExpression.create(null,
                node.base.bindings,
                body));

/**
 * Flatten curry of curry.
 */
addPeephole(['CurryExpression'], true,
    \node ->
        node.base.type === 'CurryExpression',
    modify\node ->
        ast_expression.CurryExpression.create(null,
            node.base.base,
            fun.concat(
                node.base.args,
                node.args)));

/**
 * Rewrite left pipe of curried expression to a call.
 */
addPeephole(['BinaryExpression'], true,
    \node ->
        (node.operator === '|>' && node.right.type === 'CurryExpression'),
    modify\node ->
        ast_expression.CallExpression.create(null,
            ?node.right.type === 'CurryExpression'
                :node.right.base
                :node.right,
            fun.concat(
                node.right.args || [],
                node.left)));

/**
 * Rewrite right pipe of curried expression to a call.
 */
addPeephole(['BinaryExpression'], true,
    \{operator left} ->
        (operator === '<|' && left.type === 'CurryExpression'),
    
    modify\node ->
        ast_expression.CallExpression.create(null,
            ?node.left.type === 'CurryExpression'
                :node.left.base
                :node.left,
            fun.concat(
                node.left.args || [],
                node.right)));

/* Interface
 ******************************************************************************/
var upTransforms = \node -> 
    ((node && peepholes.(node.type)) || [])
        .filter(\x -> x.up && x.condition(node));

var downTransforms = \node -> 
    ((node && peepholes.(node.type)) || [])
        .filter(\x -> !x.up && x.condition(node));

var transform = \node transforms ->
    ?transforms.length
        :seqa(transforms.map(\x -> x.map))
        :pass;

var walk = \pre post ->
    next(
        pre,
        bind(ctx, \t -> {
        if (zipper.isLeaf t) {
            var loop = next(
                post,
                bind(ctx, \t -> {
                    if (zipper.isLast t) {
                        if (zipper.isRoot t)
                            return pass;
                        return next(
                            move zipper.up,
                           loop);
                    } else {
                        return next(move zipper.right, walk(pre, post));
                    }
                }));
            return loop;
        }
        return next(move zipper.down, walk(pre, post));
    }));

var _transform = bind(node, \node ->
    transform(node, downTransforms node));

var _transformPost = bind(node, \node ->
    transform(node, upTransforms node));

var opt = walk@(_transform, _transformPost);

/**
 * 
 */
optimize = \ast data -> {
    var s = State.create(khepriZipper(ast), data.unique);
    var r = run(
        next(
            walk(_transform, _transformPost),
            node),
        s);
    console.log(r);
    return r;
};

}

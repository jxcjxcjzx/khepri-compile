/**
 * @fileOverview Lexical checking of an AST and tagging of identifiers with unique
 * ids.
 */
package (
    check)
with
    import 'khepri-ast::node' ast_node#{setData setUserData},
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
        
    import 'khepri-ast-zipper' {khepriZipper},
    
    import 'akh::base' {
        next
        'sequence':seq
        'sequencea': seqa},
    import 'akh::trans::state' StateT,
    import 'akh::identity' Identity,
    import 'akh::trans::error' ErrorT,
    import 'akh::unique' Unique,

    import './scope' scope#{Scope},
    import './fun' {foldl},
    
    import './control/zippert' ZipperT
in {

/* Forward declarations
 ******************************************************************************/
var _check;

/* Monad
 ******************************************************************************/
var Zipper = ZipperT(Unique); 
var StateM = StateT(Zipper); // TODO: should probably be reversed.

var M = ErrorT(StateM);

var run = \p s ctx ok err->
    Unique.runUnique(
        ZipperT.run(
            StateT.evalStateT(
                ErrorT.runErrorT(
                    p,
                    ok \> StateM.of,
                    err \> StateM.of),
                s),
            ctx));

var error = M.fail;

var lift = M.lift;

var unique = lift <| StateM.lift <| Zipper.lift <| Unique.unique;

// Scope Operations
////////////////////////////////////////
var extract = lift (StateM.get);

var examineScope = M.chain @ extract;

var modifyScope = lift <\ StateM.modify;;

var push = modifyScope scope.push;
var pop = modifyScope scope.pop;

// Movement Operations
////////////////////////////////////////
var inspect = M.chain @ lift(StateM.lift(Zipper.node));

var extractNode = lift <| StateM.lift <| Zipper.node;

var move = lift <\ StateM.lift <\ Zipper.move;

var up = lift (StateM.lift Zipper.up);
var down = lift (StateM.lift Zipper.down);
var left = lift (StateM.lift Zipper.left);
var right = lift (StateM.lift Zipper.right);

var root = lift (StateM.lift Zipper.root);

var moveChild =  lift <\ StateM.lift <\ Zipper.child;

var modifyNode = lift <\ StateM.lift <\ Zipper.modifyNode;
var setNode = lift <\ StateM.lift <\ Zipper.setNode;

var checkTop = inspect \ x -> _check x; // forward

var child = \args(edge ...) ->
    seq(
        moveChild edge,
        seqa([].slice.call(args, 1)),
        up);

var checkChild = \edge ->
    child(edge,
        checkTop);

/* Operations
 ******************************************************************************/
/**
 * Noop
 */
var pass = M.of();

/**
 * Create a new lexical block for body.
 */
var block = \body(...) ->
    seq(
        push,
        seqa(body),
        pop);

/**
 * Check to ensure the current scope contains a binding for `id`.
 */
var checkHasBinding = \id, loc ->
    examineScope \ s ->
        ?s.hasBinding(id)
            :pass
            :error("Undeclared identifier:'" + id + "' at:" + loc);

/**
 * Check to ensure the current scope does not have has a binding for `id`.
 */
var checkCanAddOwnBinding = \id loc -> 
    examineScope \ s ->
        ?s.hasOwnBinding(id)
            :let
                start = loc && loc.start,
                binding = s.getBinding(id),
                end = binding.loc && binding.loc.start
            in
                error("'" + id + "' at:" + start + " already bound for scope from:" + end)
            :pass;

/**
 * Check if `id` is a mutable binding.
 */
var checkCanAssign = \id, loc -> 
    examineScope \ s ->
        ?s.hasBinding(id)
            :let b = s.getBinding(id) in
                ?b.mutable
                    :pass
                    :error("Assign to immutable variable:'" + id + "' at:"+ loc)
            :pass;

/**
 * Define a new identifier and create a uid entry for it.
 */
var addUid = \id ->
    unique.chain \ uid ->
        modifyScope(\s -> Scope.addUid(s, id, uid));

/**
 * Add a new mutable binding in the current scope.
 * Does not perform any checks.
 */
var addMutableBinding = \id, loc -> 
    seq(
         modifyScope \ s ->
             Scope.addMutableBinding(s, id, loc),
         addUid(id));

/**
 * Adds a new static binding in the current scope.
 * 
 * Static binds are immutable and are not effected by renaming.
 * 
 * Does not perform any checks.
 */
var addStaticBinding = \id, loc -> 
     modifyScope \ s ->
         Scope.addImmutableBinding(s, id, loc);

/**
 * Adds a new immutable binding in the current scope.
 * Does not perform any checks.
 */
var addImmutableBinding = \id, loc -> 
    seq(
         modifyScope \ s ->
             Scope.addImmutableBinding(s, id, loc),
         addUid(id));

/**
 * Add a new mutable binding in the current scope.
 * Checks to make sure the new binding is valid.
 */
var addMutableBindingChecked = \id, loc ->
    seq(
        checkCanAddOwnBinding(id, loc),
        addMutableBinding(id, loc));

/**
 * Add a new immutable binding in the current scope.
 * Checks to make sure the new binding is valid.
 */
var addImmutableBindingChecked = \id, loc ->
    seq(
        checkCanAddOwnBinding(id, loc),
        addImmutableBinding(id, loc));

/**
 * Add a new immutable binding in the current scope.
 * Checks to make sure the new binding is valid.
 */
var addStaticBindingChecked = \id, loc ->
    seq(
        checkCanAddOwnBinding(id, loc),
        addStaticBinding(id, loc));

/* Checks
 ******************************************************************************/
var checks = {};

var addCheck = \type, check -> {
    if (Array.isArray(type))
        type.forEach \x -> addCheck(x, check);
    else
        checks.(type) = check;
};

// Program and Packages
addCheck@'Program' <|
    block(
        checkChild 'body');

addCheck@'PackageExports' <|
    checkChild 'exports';

addCheck@'PackageExport' <|
    inspect \ node ->
        addMutableBindingChecked(
            node.id.name,
            node.loc);

addCheck@'Package' <|
    block(
        addImmutableBindingChecked('require', null),
        addImmutableBindingChecked('exports', null),
        addImmutableBindingChecked('module', null),
        checkChild 'exports',
        // Evaluate body in same scope
        child('body',
            inspect \ node ->
                ?node.type === 'WithStatement'
                    :seq(
                        checkChild 'bindings',
                        child('body',
                            checkChild 'body'))
                    :checkChild 'body'));

// Clause
addCheck@'SwitchCase' <|
    seq(
        checkChild 'test',
        checkChild 'consequent');

addCheck@'CatchClause' <|
    block(
        inspect \ node ->
            addImmutableBindingChecked(node.param.name, node.param.loc),
        checkChild 'param',
        child('body',
            checkChild 'body'));

// Declarations
addCheck@['StaticDeclaration', 'VariableDeclaration'] <|
    checkChild 'declarations';

addCheck@'StaticDeclarator' <|
    inspect \ node ->
        addStaticBindingChecked(node.id.name, node.loc);

addCheck@'VariableDeclarator' <|
    inspect \ node -> let
        bind = ?node.immutable
            :addImmutableBindingChecked(node.id.name, node.loc)
            :addMutableBindingChecked(node.id.name, node.loc)
    in
        ?node.recursive
            :seq(
                bind,
                checkChild 'id',
                checkChild 'init')
            :seq(
                checkChild 'init',
                bind,
                checkChild 'id');

addCheck@'Binding' <|
    inspect \ node ->
        ?node.recursive
            :seq(
                checkChild 'pattern',
                checkChild 'value')
            :seq(
                checkChild 'value',
                checkChild 'pattern');

// Statement
addCheck@'BlockStatement' <|
    block(
        checkChild 'body');

addCheck@'ExpressionStatement' <|
    checkChild 'expression';

addCheck@'IfStatement' <|
    seq(
        checkChild 'test',
        block(
            checkChild 'consequent'),
        block(
            checkChild 'alternate'));

addCheck@'WithStatement' <|
     block(
        checkChild 'bindings',
        child('body',
            checkChild 'body'));

addCheck@'SwitchStatement' <|
    block(
        checkChild 'discriminant',
        checkChild 'cases');

addCheck@['ReturnStatement', 'ThrowStatement'] <|
    checkChild 'argument';

addCheck@'TryStatement' <|
    seq(
        checkChild 'block',
        block(
            checkChild 'handler'),
        block(
            checkChild 'finalizer'));

addCheck@'WhileStatement' <|
    seq(
        checkChild 'test',
        block(
            checkChild 'body'));

addCheck@'DoWhileStatement' <|
    seq(
        block(
            checkChild 'body'),
        checkChild 'test');

addCheck@'ForStatement' <|
    block(
        checkChild 'init',
        checkChild 'test',
        checkChild 'update',
        block(
            checkChild 'body'));

// Expression
addCheck@'FunctionExpression' <|
    block(
         inspect \ node ->
             ?node.id
                 :addImmutableBinding(node.id.name, node.loc)
                 :pass,
         checkChild 'params',
         inspect \ node ->
             ?node.body.type === "BlockStatement"
                 :child('body',
                     checkChild 'body')
                 :checkChild 'body');

addCheck@'UnaryExpression' <|
    checkChild 'argument';

addCheck@'AssignmentExpression' <|
    seq(
        child('left',
            checkTop,
            inspect \ left ->
                ?left.type === 'Identifier'
                    :checkCanAssign(left.name, left.loc)
                    :pass),
        checkChild 'right');

addCheck@['LogicalExpression', 'BinaryExpression'] <|
    seq(
        checkChild 'left',
        checkChild 'right');

addCheck@'ConditionalExpression' <|
    seq(
        checkChild 'test',
        checkChild 'consequent',
        checkChild 'alternate');

addCheck@['CallExpression', 'NewExpression'] <|
    seq(
        checkChild 'callee',
        checkChild 'args');

addCheck@'MemberExpression' <|
    seq(
        checkChild 'object',
        inspect \ node ->
            ?node.computed
                :checkChild 'property'
                :pass);
    
addCheck@'ArrayExpression' <|
    checkChild 'elements';

addCheck@'ObjectExpression' <|
    checkChild 'properties';

addCheck@'LetExpression' <|
    block(
        checkChild 'bindings',
        checkChild 'body');

addCheck@'CurryExpression' <|
    seq(
        checkChild 'base',
        checkChild 'args');

// Patterns
addCheck@'SinkPattern'<|
    unique.chain \ uid ->
        setNode <|
            setData(
                ast_value.Identifier.create(null, '_'),
                'uid',
                uid);

addCheck@'IdentifierPattern' <|
    seq(
        inspect \ node ->
            ?node.reserved
                :addImmutableBinding(node.id.name, node.loc)
                :addImmutableBindingChecked(node.id.name, node.loc),
        checkChild 'id');

addCheck@'ImportPattern' <|
    checkChild 'pattern';

addCheck@'AsPattern' <|
    seq(
        checkChild 'id',
        inspect \ node ->
            child('target',
                modifyNode \ target ->
                    // Hack: For generating argument lists, we want to used the 
                    // as pattern name if possible.
                    setData(target, 'id', node.id),
                checkTop));

addCheck@'ObjectPattern' <|
    inspect \ node -> {
        if (!node.ud || !node.ud.id) {
            return seq(
                unique.chain \ uid -> {
                    var id = ast_pattern.IdentifierPattern.create(node.loc,
                        setData(
                            ast_value.Identifier.create(null, '__o'),
                            'uid',
                            uid));
                    
                    // TODO: Hack. Tells later check not to complain if '__o' is not unique
                    // because this doesn't matter since the uid is unique.
                    id.reserved = true;
                    
                    return setNode(ast_pattern.AsPattern.create(null, id, node));
                },
                checkTop);
        }
        return checkChild 'elements';
    };

addCheck@'ObjectPatternElement' <|
    seq(
        checkChild 'target',
        checkChild 'key');

addCheck@'ArgumentsPattern' <|
    seq(
        checkChild 'id',
        checkChild 'elements',
        checkChild 'self');

// Value
addCheck@'ObjectValue' <|
    checkChild 'value';

addCheck@'Identifier' <|
    inspect \ node ->
        seq(
            examineScope \ s ->
                 setNode <| setData(node, 'uid', s.getUid(node.name)),
            checkHasBinding(node.name, node.loc));

/*
 ******************************************************************************/
_check = \node -> {
    if (Array.isArray(node)) {
        if (!node.length)
            return pass;
        
        return seq(
            down,
            seqa(node.map(\_ i -> 
                ?i === node.length - 1
                    :checkTop
                    :next(checkTop, right))),
            up);
    }
    
    if (node instanceof ast_node.Node && checks.(node.type))
        return checks.(node.type);
    
    return pass;
};

var initialScope = foldl@(Scope.addImmutableBinding, Scope.empty);

/**
 * 
 */
check = let
    suc = \x,s -> x,
    fail = \x -> { throw x; }
in
    \ast globals ->
        run(
            seq(
                checkTop,
                root,
                extractNode.chain \ x ->
                unique.chain \ unique ->
                extract.map \ s ->
                    ({'tree': x , 'data': {'unique': unique}})),
            initialScope(globals || []),
            khepriZipper(ast),
            suc,
            fail);
}
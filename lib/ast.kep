/**
 * @fileOverview Khepri AST nodes predicates.
 */
package (
    type
    
    isIdentifier
    
    isLiteral
    isNumberish
    isPrimitive
    isSimple
    isPod
    
    isTruthy
    
    isBlockFunction
    isLambda
    isLambdaWithoutArgs

    tryGetUd
    getUd
    setUd
    
    getUid
    setUid)
with
    import 'khepri-ast::node' {setData}
in{

/**
 * Safe node type getter
 */
type := \node ->
    (node && node.type);

/* Identifier
 ******************************************************************************/
/**
 * Is a node an identifier?
 */
isIdentifier = type \> (===, 'Identifier');

/* Literal
 ******************************************************************************/
/**
 * Is a node a literal.
 * 
 * This includes regular expressions.
 */
isLiteral = type \> (===, 'Literal');

/**
 * Can a node be treated as a number?
 */
isNumberish = \node ->
    (  isPrimitive node
    && !isNaN node.value);

/**
 * Is a node a primitive value.
 */
isPrimitive = \node ->
    isLiteral node && (
        node.kind === 'string'
        || node.kind === 'number'
        || node.kind === 'boolean'
        || node.kind === 'null');

/**
 * Is a node a language literal?
 */
isSimple = \node ->
    (  isLiteral node 
    || type node === 'ArrayExpression'
    || type type === 'ObjectExpression');

/**
 * Is a node plain old data?
 * 
 * Plain old data includes all primitives as well as arrays and objects, so long
 * as those object contain only pod.
 */
isPod = \node ->
    (  isPrimitive node
    || type node === 'ArrayExpression' && node.elements.every(isPod)
    || type type === 'ObjectExpression' && node.elements.every((.value) \> isPod));

/* Value
 ******************************************************************************/
/**
 * Is a node a constant truthy value.
 */
isTruthy = \node ->
    (  isPrimitive node
    && !!node.value);

/* Function
 ******************************************************************************/
/**
 * Is a node a function with a block body?
 */
isBlockFunction = \node ->
    (  type node === 'FunctionExpression'
    && type node.body === 'BlockStatement');

/**
 * Is a function a lambda function? Includes functions that use the arguments
 * object.
 */
isLambda = \node ->
    (  type node === 'FunctionExpression'
    && !node.id
    && !isBlockFunction node
    && !node.params.self);

/**
 * Is a function a lambda function that does not use the arguments object?
 */
isLambdaWithoutArgs = \node ->
    (  isLambda node
    && !node.params.id);

/* User Data
 ******************************************************************************/
/**
 * Get the user data `key` or return null.
 */
tryGetUd := \def key node ->
    ?node && node.ud && node.ud.hasOwnProperty(key)
        :node.ud.(key)
        :def;

/**
 * Get the user data `key` or return null.
 */
getUd := tryGetUd @ null;

/**
 * Set the user data for `key` to `value` on `node`.
 */
setUd := \key value node ->
    setData(node, key, value);

/**
 * Get the uid of a node or null.
 */
getUid := getUd @ 'uid';

/**
 * Set the uid of a node.
 * 
 * @param uid
 * @param node
 */
setUid := setUd @ 'uid';

}
/**
 * @fileOverview
 * 
 * @TODO: move all translate specific logic out of this file.
 */
package (
    transform)
with 
    import 'ecma-ast::clause' ecma_clause,
    import 'ecma-ast::declaration' ecma_declaration,
    import 'ecma-ast::expression' ecma_expression,
    import 'ecma-ast::statement' ecma_statement,
    import 'ecma-ast::value' ecma_value,
    
    import 'ecma-ast-zipper' {ecmaZipper},
    
    import 'akh::unique' Unique,
    import 'akh::trans::statei' StateT,
    import 'akh::base' {
        liftM2
        'sequence': seq,
        sequencea},
    
    import 'zipper-m::trans::tree' TreeZipperT,
    
    import '../ast' {
        type
        getUd
        setUd
        getUid
        setUid},
    import '../lexical/scope' scope#{Scope},
    import '../fun' {
        concat
        flatten
        flip
        foldr
        map},
    import '../builtin' {builtins},
    import './unpack' {
        expandBindings},
    import './state' state#{State},
    import './translation' translate,
    
    import './package_manager/amd' _,
    import './package_manager/node' _
in {

/* Forward
 ******************************************************************************/
var _trans;

/* Monad
 ******************************************************************************/
var M := TreeZipperT (StateT Unique);

var run = \m s ctx seed ->
    Unique.runUnique(
        StateT.evalStateT(
            TreeZipperT.runTreeZipperT(m, ctx),
            s),
        seed);

var pass := M.of null;

var cons := liftM2 @ concat;

var enumeration := foldr@(flip cons, M.of []);

/* Operations
 ******************************************************************************/
// State Operations
////////////////////////////////////////
var extract = M.lift (M.inner.get);

var setState = M.lift <\ M.inner.put;

var modifyState = M.lift <\ M.inner.modify;

var inspectStateWith = M.chain @ extract;

var packageManager = extract.map (.packageManager);

// Zipper Operations
////////////////////////////////////////
var node = M.node;

var withNode = M.chain @ node;

var modify = M.modifyNode;
var set = M.setNode;

var up = M.up;
var down = M.down;
var right = M.right;

var moveChild = M.child;

var child := \edge ...actions ->
    seq(
        moveChild edge,
        sequencea actions,
        up);

var checkTop := node.chain \ x -> _trans x; // forward

var checkChild := \edge ->
    child(edge,
        checkTop);

// Scoping Operations
////////////////////////////////////////
var inspectScope = \f -> extract.map (f <\ (.scope));

var inspectScopeWith = \f -> extract.chain(f <\ (.scope));

var modifyScope = \f ->
    modifyState \ s ->
        s.setScope(f s.scope);

/**
 * Enter a new real scope.
 */
var enterBlock = modifyScope (scope.push);

/**
 * Exit the current real scope.
 */
var exitBlock = modifyScope (scope.pop);

/**
 * Perform `actions` in an new real block.
 */
var realBlock := \actions(...) ->
    seq(
    enterBlock,
    sequencea actions,
    exitBlock);

/**
 * Get the identifier name for `uid`.
 */
var getMapping = \uid ->
    inspectScope \ s ->
        s.getMapping(uid);

/**
 * Add an new identifier in the current scope.
 * 
 * @param id Source id name.
 * @param uid Unique id.
 */
var addVar = \id uid ->
    modifyScope (scope.addVar@(id, uid));

// Bindings Operations
////////////////////////////////////////
var pushBindings = modifyState (state.pushBindings);

var popBindings = modifyState (state.popBindings);

/**
 * Get all bindings in the current scope.
 */
var getBindings = M.chain @ inspectStateWith(
    enumeration
        <\ map @ getMapping
        <\ state.getBindings);

/**
 * 
 */
var addBindings = \bindings ->
    modifyState (state.addBindings @ bindings);

/**
 * 
 */
var addBindingsForBindingsList :=
    map @ ((.pattern) \> expandBindings@null)
    \> flatten
    \> map @ ((.pattern) \> (.id) \> getUid)
    \> addBindings;

/* Values
 ******************************************************************************/
var identifier = \loc, name uid ->
    setUid(
        uid,
        ecma_value.Identifier.create(loc, name));

/* Transforms
 ******************************************************************************/
var transformers = {};

var addTransform = \type check -> {
    if (Array.isArray type)
        type.forEach \ x -> addTransform(x, check);
    else
        transformers.(type) = check;
};

var _transform = withNode \node -> _trans(node); // Late

// Declarations
addTransform@'VariableDeclaration' <| seq(
    checkChild 'declarations',
    modify \ {loc declarations} ->
        ecma_declaration.VariableDeclaration.create(loc,
            declarations));

addTransform@'Binding' <| seq(
    child('pattern',
        checkChild 'id'),
    checkChild 'value');

addTransform@'VariableDeclarator' <| seq(
    checkChild 'id',
    checkChild 'init',
    modify \ node ->
        ecma_declaration.VariableDeclarator.create(node.loc,
            node.id,
            node.init));

addTransform@'StaticDeclaration' <|
    modify \ {loc} ->
        ecma_statement.EmptyStatement.create(loc);

// Clauses
addTransform@'CatchClause' <| seq(
    checkChild 'param',
    checkChild 'body',
    modify \ node ->
        ecma_clause.CatchClause.create(node.loc,
            node.param,
            node.body));

addTransform@'SwitchCase' <| seq(
    checkChild 'test',
    checkChild 'consequent',
    modify \ node ->
        ecma_clause.SwitchCase.create(node.loc,
            node.test,
            node.consequent));

// Statement
addTransform@'BlockStatement' <| seq(
    pushBindings,
    checkChild 'body',
    getBindings \ bindings ->
        modify (translate.blockStatement @ bindings),
    popBindings);

addTransform@'ExpressionStatement' <| seq(
    checkChild 'expression',
    modify (translate.expressionStatement));

addTransform@'IfStatement' <| seq(
    checkChild 'test',
    checkChild 'consequent',
    checkChild 'alternate',
    modify (translate.ifStatement));

addTransform@'WithStatement' <| seq(
    checkChild 'bindings',
    checkChild 'body',
    modify \ node ->
        translate.withStatement(
            node.loc,
            node.bindings,
            node.body));

addTransform@'SwitchStatement' <| seq(
    checkChild 'discriminant',
    checkChild 'cases',
    modify (translate.switchStatement));

addTransform@'ReturnStatement' <| seq(
    checkChild 'argument',
    modify (translate.returnStatement));;

addTransform@'ThrowStatement' <| seq(
    checkChild 'argument',
    modify (translate.throwStatement));

addTransform@'BreakStatement' <|
    modify (translate.breakStatement);

addTransform@'ContinueStatement' <|
    modify (translate.continueStatement);

addTransform@'TryStatement' <| seq(
    checkChild 'block',
    checkChild 'handler',
    checkChild 'finalizer',
    modify (translate.tryStatement));

addTransform@'WhileStatement' <| seq(
    checkChild 'test',
    checkChild 'body',
    modify (translate.whileStatement));

addTransform@'DoWhileStatement' <| seq(
    checkChild 'body',
    checkChild 'test',
    modify (translate.doWhileStatement));

addTransform@'ForStatement' <| seq(
    checkChild 'init',
    checkChild 'test',
    checkChild 'update',
    checkChild 'body',
    modify (translate.forStatement));

// Expression
addTransform@'AssignmentExpression' <| seq(
    checkChild 'left',
    checkChild 'right',
    modify (translate.assignmentExpression));

addTransform@'UnaryExpression' <| seq(
    checkChild 'argument',
    modify (translate.unaryExpression));

addTransform@'BinaryExpression' <| seq(
    checkChild 'left',
    checkChild 'right',
    modify (translate.binaryExpression));

addTransform@'LogicalExpression' <| seq(
    checkChild 'left',
    checkChild 'right',
    modify (translate.logicalExpression));

addTransform@'ConditionalExpression' <| seq(
    checkChild 'test',
    checkChild 'consequent',
    checkChild 'alternate',
    modify (translate.conditionalExpression));

addTransform@'NewExpression' <| seq(
    checkChild 'callee',
    checkChild 'args',
    modify (translate.newExpression));

addTransform@'CallExpression' <| seq(
    checkChild 'callee',
    checkChild 'args',
    modify (translate.callExpression));

addTransform@'MemberExpression' <| seq(
    checkChild 'object',
    checkChild 'property',
    modify (translate.memberExpression));

addTransform@'LetExpression' <| seq(
    checkChild 'bindings',
    withNode ((.bindings) \> addBindingsForBindingsList),
    checkChild 'body',
    modify \ node ->
        translate.letExpression(node.loc,
            node.bindings,
            node.body));

addTransform@'CurryExpression' <| seq(
    checkChild 'base',
    checkChild 'args',
    modify \ node ->
        translate.curryExpression(node.loc,
            node.base,
            node.args));

addTransform@'FunctionExpression' <|
    realBlock(
        checkChild 'id',
        modify \ node ->
            translate.functionExpression(node.loc,
                node.id,
                node.params,
                node.body,
                getUd('prefix', node)),
        
        checkChild 'params',
        checkChild 'body',
        
        modify \ node ->
            ecma_expression.FunctionExpression.create(null,
                node.id,
                node.params,
                node.body));

addTransform@'ArrayExpression' <| seq(
    checkChild 'elements',
    modify \ node ->
        ecma_expression.ArrayExpression.create(node.loc,
            node.elements));

addTransform@'ObjectExpression' <| seq(
    checkChild 'properties',
    modify \ node ->
        ecma_expression.ObjectExpression.create(node.loc,
            node.properties));

addTransform@'ObjectValue' <| seq(
    checkChild 'key',
    checkChild 'value',
    modify \ node ->
        ecma_value.ObjectValue.create(node.loc,
            node.key,
            node.value));

// Patterns
addTransform@['RelativeUnpack', 'SliceUnpack'] <|
    checkChild 'target';

addTransform@'ArgumentsPattern' <| seq(
    checkChild 'id',
    checkChild 'elements',
    checkChild 'self');

addTransform@['IdentifierPattern', 'AsPattern'] <| seq(
    checkChild 'id',
    modify (.id));

addTransform@['ObjectPattern', 'EllipsisPattern'] <| seq(
    modify (getUd @ 'id'));

// Program
addTransform@'Program' <|
    let
        useStrict =
            ecma_statement.ExpressionStatement.create(null,
                ecma_value.Literal.create(null, 'string', "use strict"))
    in seq(
        pushBindings,
        
        // Add 'use strict' header to non-package programs.
        modify \ node ->
            ?type node.body === 'Package'
                :node
                :setUd('prefix', useStrict, node),
        
        checkChild 'body',
        getBindings \ bindings ->
            modify (translate.program @ bindings));

// Package
addTransform@'Package' <| seq(
    packageManager.chain \ packageManager ->
    modify \ node ->
        translate.packageBlock(
            packageManager,
            node.loc,
            node.exports,
            node.body),
    
    // the package managers are expressed in khepri code so we have to translate the output
    _transform); 

addTransform@'Import' <|
    packageManager.chain \ packageManager ->
        modify ((.from) \> packageManager.importPackage);

// Value
addTransform@'Identifier' <|
    withNode \ node ->
        ?getUid node
            // When node has uid, get mapped name for uid.
            :seq(
                addVar(node.name, getUid node),
                getMapping(getUid node).chain \ name ->
                    set <| identifier(node.loc, name, getUid node))
        
        // When node has no uid, don't rename
        :set <| identifier(node.loc, node.name);

/*
 *****************************************************************************/
/**
 * Visit an array node.
 */
var visitArray := let
    move = \x i a ->
        ?i === a.length - 1
            :checkTop
            :seq(checkTop, right)
in
    \node ->
        ?node.length
            :seq(
                down,
                sequencea map(move, node),
                up)
        :pass;

/**
 * 
 */
_trans  = \node ->
    ?Array.isArray node
        :visitArray node
        :(transformers.(type node) || pass);

var rewrite := checkTop;

var transformProgram := seq(
    addVar('require', getUid(builtins.require)),
    addVar('exports', getUid(builtins.exports)),
    rewrite,
    node.map (ecmaZipper));

/* API
 *****************************************************************************/
var getPackageManager = \manager -> {
    with 
        import './package_manager/amd' amd_manager,
        import './package_manager/node' node_manager
    in {
        return ?manager === 'node' : node_manager : amd_manager;
    }
};

/**
 * Rewrite a Khepri zippered program to an ECMAScript program.
 * 
 * Outputs the ECMAScript root.
 * 
 * @param ast Zippered khepri program.
 * @param manager Package manager to use for rewrite.
 */
transform = \ast manager -> let
    packageManager = getPackageManager manager,

    s = State.empty
        .setPackageManager(packageManager)
in
    run(transformProgram, s, ast);

}
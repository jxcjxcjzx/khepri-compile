/**
 * @fileOverview
 */
package (
    transform)
with 
    import 'ecma-ast::clause' ecma_clause,
    import 'ecma-ast::declaration' ecma_declaration,
    import 'ecma-ast::expression' ecma_expression,
    import 'ecma-ast::node' ecma_node,
    import 'ecma-ast::program' ecma_program,
    import 'ecma-ast::statement' ecma_statement,
    import 'ecma-ast::value'ecma_value,
    
    import 'ecma-ast-zipper' {ecmaZipper},
    
    import 'khepri-ast::declaration' khepri_declaration,
    import 'khepri-ast::expression' khepri_expression,
    import 'khepri-ast::node' khepri_node#{setData},
    import 'khepri-ast::statement' khepri_statement,
    import 'khepri-ast::value' khepri_value,
    
    import 'akh::unique' Unique,
    import 'akh::trans::statei' StateT,
    import 'akh::base' {
        liftM2
        'sequence': seq},
    
    import 'zipper-m::trans::tree' TreeZipperT,
    import 'zipper-m::walk' walk,
    
    import '../ast' {
        type
        tryGetUd
        getUd
        getUid},
    import '../lexical/scope' scope#{Scope},
    import '../fun' fun#{
        concat
        flatten
        flip
        filter
        foldr
        map
        reduce},
    import '../builtin' {builtins},
    import './unpack' {
        expandBinding
        expandBindings
        expandArgumentsPattern},

    import './state' state#{State},
    
    import './package_manager/amd' _,
    import './package_manager/node' _
in {

/* Monad
 ******************************************************************************/
var M = TreeZipperT (StateT Unique);

var run = \m s ctx seed ->
    Unique.runUnique(
        StateT.evalStateT(
            TreeZipperT.runTreeZipperT(m, ctx),
            s),
        seed);

var pass = M.of null;

var cons = liftM2 @ concat;

var enumeration = foldr@(flip cons, M.of []);

/* Operations
 ******************************************************************************/
// State Operations
////////////////////////////////////////
var extract = M.lift (M.inner.get);

var setState = M.lift <\ M.inner.put;

var modifyState = M.lift <\ M.inner.modify;

var inspectStateWith = M.chain @ extract;

var packageManager = extract.map (.packageManager);

// Zipper Operations
////////////////////////////////////////
var node = M.node;

var withNode = M.chain @ node;

var modify = M.modifyNode;
var set = M.setNode;

// Scoping Operations
////////////////////////////////////////
var inspectScope = \f -> extract.map (f <\ (.scope));

var inspectScopeWith = \f -> extract.chain(f <\ (.scope));

var setScope = \scope ->
    modifyState \ s ->
        s.setScope(scope);

var modifyScope = \f ->
    modifyState \ s ->
        s.setScope(f s.scope);

/**
 * Enter a new real scope.
 */
var enterBlock = modifyScope (scope.push);

/**
 * Exit the current real scope.
 */
var exitBlock = modifyScope (scope.pop);

/**
 * Get the identifier name for `uid`.
 */
var getMapping = \uid ->
    inspectScope \ s ->
        s.getMapping(uid);

/**
 * Add an new identifier in the current scope.
 * 
 * @param id Source id name.
 * @param uid Unique id.
 */
var addVar = \id uid ->
    inspectScopeWith \ s ->
        ?s.hasMapping(uid)
            :setScope <|
                scope.addMutableBinding(s, id)
            
        :let name = s.getUnusedId(id) in
            setScope <|
                scope.addMapping(
                    scope.addMutableBinding(s, name),
                    uid,
                    name);

// Bindings Operations
////////////////////////////////////////
var pushBindings = modifyState (state.pushBindings);

var popBindings = modifyState (state.popBindings);

var addBindings = \bindings ->
    modifyState (state.addBindings @ bindings);

/**
 * Get all bindings in the current scope.
 */
var getBindings = M.chain @ inspectStateWith(
    enumeration
        <\ map @ getMapping
        <\ state.getBindings);

/* Forward
 ******************************************************************************/
var _trans;

var _transform = withNode \node -> _trans(node); // Late

/* Values
 ******************************************************************************/
var identifier = \loc, name ->
    ecma_value.Identifier.create(loc, name);

/* Declaration
 ******************************************************************************/
var variableDeclaration = khepri_declaration.VariableDeclaration.create;

var variableDeclarator = ecma_declaration.VariableDeclarator.create;

var idsToDeclarators :=
    map @ \x ->
        ecma_declaration.VariableDeclarator.create(null,
            identifier(null, x)) ยง
    \> ecma_declaration.VariableDeclaration.create @ null;

/* Unpacks
 ******************************************************************************/
/**
 * Convert a binding to a variable declarator.
 */
var bindingToDeclarator = \x ->
    variableDeclarator(null,
        x.pattern,
        x.value);

/**
 * Expand a binding to a list of variable declarations.
 */
var unpack = expandBinding \> map @ bindingToDeclarator;

/**
 * Expand an binding to a list of assignments.
 */
var unpackAssign =
    expandBinding
    \> map @ \x ->
        ecma_expression.AssignmentExpression.create(null, '=', x.pattern, x.value);

/* Statements
 ******************************************************************************/
/**
 * With statement translation.
 */
var withStatementNoImport = \loc bindings body -> let
    vars = flatten <| map(unpack, bindings),
    
    prefix = variableDeclaration(null, vars)
in
    khepri_statement.BlockStatement.create(loc,
        concat(
            prefix,
            body.body));

/**
 * With statement translation.
 */
var withStatement = \packageManager, loc, bindings, body -> let
    flattenImport = \imp ->
        ?type imp === 'ImportPattern'
            :khepri_declaration.Binding.create(null,
                imp.pattern,
                packageManager.importPackage(imp.from.value))
            :imp
in
    withStatementNoImport(loc,
        map(flattenImport, bindings),
        body);

/* Expressions
 ******************************************************************************/
/**
 * Function Expression Normalization.
 */
var functionExpression = \loc id parameters functionBody prefix -> let
    params = parameters.elements,
    
    bindings = expandArgumentsPattern(parameters, ecma_expression.ThisExpression.create(null))
        |> map @ bindingToDeclarator,
    
    body = ?type functionBody === "BlockStatement"
        :functionBody.body
        :khepri_statement.ReturnStatement.create(null, functionBody)
in
    khepri_expression.FunctionExpression.create(loc,
        id,
        params,
        khepri_statement.BlockStatement.create(body.loc,
            concat(
                (prefix || []),
                variableDeclaration(null, bindings),
                body)));

/**
 * Let expression normalization.
 */
var letExpression = \loc bindings body ->
    ecma_expression.SequenceExpression.create(null,
        flatten concat(
            map(unpackAssign, bindings),
            body));

/**
 * Curry expression translation.
 */
var curryExpression = \loc base args ->
    khepri_expression.CallExpression.create(loc,
        khepri_expression.MemberExpression.create(null,
            base,
            identifier(null, 'bind')),
        concat(
            ecma_value.Literal.create(null, 'null', null),
            args));

/* Package
 ******************************************************************************/
var packageBlock = \packageManager loc exports body -> let
    imports =
        ?type body === 'WithStatement'
            :filter(type \> (===, 'ImportPattern'), body.bindings)
            :[],
    
    targets =
        reduce(imports, \p c -> {
            p.(c.from.value) = c.pattern;
            return p;
        }, {}),
    
    fBody =
        ?type body === 'WithStatement'
            :khepri_statement.WithStatement.create(null,
                filter(type \> (!==, 'ImportPattern'), body.bindings),
                body.body)
            :body
in
    packageManager.definePackage(loc,
        exports,
        imports,
        targets,
        fBody);

/* Transforms
 ******************************************************************************/
var transformers = {};

var addTransform = \type pre post -> {
    if (Array.isArray(type))
        return type.map \ x -> addTransform(x, pre, post);
    
   transformers.(type) = { pre: pre, post: post };
};

// Declarations
addTransform('VariableDeclaration',
    null,
    modify \ {loc declarations} ->
        ecma_declaration.VariableDeclaration.create(loc,
            declarations));

addTransform('VariableDeclarator',
    null,
    modify \ node ->
        ecma_declaration.VariableDeclarator.create(node.loc,
            node.id,
            node.init));

addTransform('StaticDeclaration',
    modify \ {loc} ->
        ecma_statement.EmptyStatement.create(loc));

// Clauses
addTransform('CatchClause',
    null,
    modify \ node ->
        ecma_clause.CatchClause.create(node.loc,
            node.param,
            node.body));

addTransform('SwitchCase',
    null,
    modify \ node ->
        ecma_clause.SwitchCase.create(node.loc,
            node.test,
            node.consequent));

// Statement
addTransform('BlockStatement',
    pushBindings,
    seq(
        getBindings \ bindings ->
            modify \ node ->
                ecma_statement.BlockStatement.create(node.loc,
                    concat(
                        idsToDeclarators(bindings),
                        node.body)),
        popBindings));

addTransform('ExpressionStatement',
    null,
    modify \ node ->
        ecma_statement.ExpressionStatement.create(node.loc,
            node.expression));

addTransform('IfStatement',
    null,
    modify \ node ->
        ecma_statement.IfStatement.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('WithStatement',
    seq(
        packageManager.chain \ packageManager -> 
            modify \ node ->
                withStatement(
                    packageManager,
                    node.loc,
                    node.bindings,
                    node.body),
        _transform));

addTransform('SwitchStatement',
    null,
    modify \ node ->
        ecma_statement.SwitchStatement.create(node.loc,
            node.discriminant,
            node.cases));

addTransform('ReturnStatement',
    null,
    modify \ node ->
        ecma_statement.ReturnStatement.create(node.loc,
            node.argument));

addTransform('ThrowStatement',
    null,
    modify \ node ->
        ecma_statement.ThrowStatement.create(node.loc,
            node.argument));

addTransform('BreakStatement',
    modify \ node ->
        ecma_statement.BreakStatement.create(node.loc,
            null));

addTransform('ContinueStatement',
    modify \ node ->
        ecma_statement.ContinueStatement.create(node.loc,
            null));

addTransform('TryStatement',
    null,
    modify \ node ->
        ecma_statement.TryStatement.create(node.loc,
            node.block,
            node.handler,
            node.finalizer));

addTransform('WhileStatement',
    null,
    modify \ node ->
        ecma_statement.WhileStatement.create(node.loc,
            node.test,
            node.body));

addTransform('DoWhileStatement',
    null,
    modify \ node ->
        ecma_statement.DoWhileStatement.create(node.loc,
            node.body,
            node.test));

addTransform('ForStatement',
    null,
    modify \ node ->
        ecma_statement.ForStatement.create(node.loc,
            node.init,
            node.test,
            node.update,
            node.body));

// Expression
addTransform('AssignmentExpression',
    null,
    modify \ node ->
        ecma_expression.AssignmentExpression.create(node.loc,
            '=',
            node.left,
            node.right));

addTransform('UnaryExpression',
    null,
    modify \ node ->
        ecma_expression.UnaryExpression.create(node.loc,
            ?node.operator === '++'
                :'+'
            :?node.operator === '--'
                :'-'
            :node.operator,
            node.argument));

addTransform('BinaryExpression',
    null,
    modify \ node ->
        ecma_expression.BinaryExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('LogicalExpression',
    null,
    modify \ node ->
        ecma_expression.LogicalExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('ConditionalExpression',
    null,
    modify \ node ->
        ecma_expression.ConditionalExpression.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('NewExpression',
    null,
    modify \ node ->
        ecma_expression.NewExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('CallExpression',
    null,
    modify \ node ->
        ecma_expression.CallExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('MemberExpression',
    null,
    modify \ node ->
        ecma_expression.MemberExpression.create(node.loc,
            node.object,
            node.property,
            node.computed));

addTransform('LetExpression',
    seq(
        withNode \ node -> let
            bindings = flatten <| map(\x -> ?x : expandBindings(null, x.pattern) : [], node.bindings),
            identifiers = map(\x -> getUid(x.pattern.id), bindings)
        in
            addBindings(identifiers),
        
        modify \ node ->
            letExpression(node.loc,
                node.bindings,
                node.body)));

addTransform('CurryExpression',
    modify \ node ->
        curryExpression(node.loc,
            node.base,
            node.args));

addTransform('FunctionExpression',
    seq(
        enterBlock,
        modify \ node ->
            functionExpression(node.loc,
                node.id,
                node.params,
                node.body,
                getUd('prefix', node))),
    seq(
        modify \ node ->
            ecma_expression.FunctionExpression.create(null,
                node.id,
                node.params,
                node.body),
        exitBlock));

addTransform('ArrayExpression',
    null,
    modify \ node ->
        ecma_expression.ArrayExpression.create(node.loc,
            node.elements));

addTransform('ObjectExpression',
    null,
    modify \ node ->
        ecma_expression.ObjectExpression.create(node.loc,
            node.properties));

addTransform('ObjectValue',
    null,
    modify \ node ->
        ecma_value.ObjectValue.create(node.loc,
            node.key,
            node.value));

// Patterns
addTransform(['IdentifierPattern', 'AsPattern', 'ArgumentsPattern'],
    null,
    modify (.id));

addTransform(['ObjectPattern', 'EllipsisPattern', 'SinkPattern'],
    null,
    modify (getUd @ 'id'));

// Program
addTransform('Program',
    let
        useStrict =
            khepri_statement.ExpressionStatement.create(null,
                khepri_value.Literal.create(null, 'string', "use strict"))
    in
        seq(
            pushBindings,
            modify \ node ->
                ?type node.body === 'Package'
                    :node
                    :setData(node, 'prefix', useStrict)),
        
    getBindings \ bindings ->
    modify \ node ->
        ecma_program.Program.create(node.loc,
            concat(
                ?tryGetUd([], 'prefix', node),
                idsToDeclarators(bindings),
                node.body)));

// Package
addTransform('Package',
    packageManager.chain \ packageManager ->
    modify \ node ->
        packageBlock(
            packageManager,
            node.loc,
            node.exports,
            node.body));

// Value
addTransform('Identifier',
    null,
    withNode \ node ->
        ?getUid node
            // When node has uid, get mapped name for uid.
            :seq(
                addVar(node.name, getUid node),
                getMapping(getUid node).chain \ name ->
                    set <| identifier(node.loc, name))
        
        // When node has no uid, don't rename
        :set <| identifier(node.loc, node.name));

/*
 *****************************************************************************/
_trans = \node ->
    ?node instanceof khepri_node.Node
        :let t = transformers.(type node) in
            (t && t.pre) || pass
    :pass;

var _transp = \node ->
    ?node instanceof khepri_node.Node
        :let t = transformers.(type node) in
            (t && t.post) || pass
    :pass;

var _transformPost := withNode _transp;

var rewrite := walk(M, _transform, _transformPost);

var transformProgram := seq(
    addVar('require', getUid(builtins.require)),
    addVar('exports', getUid(builtins.exports)),
    rewrite,
    node.map (ecmaZipper));

/* API
 *****************************************************************************/
var getPackageManager = \manager -> {
    with 
        import './package_manager/amd' amd_manager,
        import './package_manager/node' node_manager
    in {
        return ?manager === 'node' : node_manager : amd_manager;
    }
};

/**
 * Rewrite a Khepri zippered program to an ECMAScript program.
 * 
 * Outputs the ECMAScript root.
 * 
 * @param ast Zippered khepri program.
 * @param manager Package manager to use for rewrite.
 */
transform = \ast manager -> let
    packageManager = getPackageManager manager,

    s = State.empty
        .setPackageManager(packageManager)
in
    run(transformProgram, s, ast);

}
/**
 * @fileOverview
 */
package (
    transform)
with 
    import 'bes::record' record,

    import 'ecma-ast::clause' ecma_clause,
    import 'ecma-ast::declaration' ecma_declaration,
    import 'ecma-ast::expression' ecma_expression,
    import 'ecma-ast::node' ecma_node,
    import 'ecma-ast::program' ecma_program,
    import 'ecma-ast::statement' ecma_statement,
    import 'ecma-ast::value'ecma_value,
    
    import 'khepri-ast::declaration' khepri_declaration,
    import 'khepri-ast::expression' khepri_expression,
    import 'khepri-ast::node' khepri_node#{setData},
    import 'khepri-ast::pattern' khepri_pattern,
    import 'khepri-ast::statement' khepri_statement,
    import 'khepri-ast::value' khepri_value,
    
    import 'akh::unique' Unique,
    import 'akh::trans::statei' StateT,
    import 'akh::base' {
        liftM2
        next
        'sequence': seq},
    
    import 'zipper-m::trans::tree' TreeZipperT,
    import 'zipper-m::walk' walk,
    
    import '../ast' {type getUid},
    import '../lexical/scope' scope#{Scope},
    import '../fun' fun#{
        concat
        flatten
        flip
        filter},
    import '../builtin' {builtins definitions},
    import '../inline/unpack' {unpackParameters},
    import './unpack' {expandBinding expandBindings},

    import './package_manager/amd' _,
    import './package_manager/node' _
in {

/* Values
 ******************************************************************************/
var identifier = \loc, name ->
    ecma_value.Identifier.create(loc, name);

var nullLiteral = \loc ->
    ecma_value.Literal.create(loc, 'null', null);

/* Declaration
 ******************************************************************************/
var variableDeclaration = khepri_declaration.VariableDeclaration.create;

var variableDeclarator = ecma_declaration.VariableDeclarator.create;

/* State
 ******************************************************************************/
var State = record.declare(null, [
    'scope',
    'packageManager',
    'bindings']);

State.empty = State.create(
    Scope.empty,
    null,
    [[], null]);

/* Monad
 ******************************************************************************/
var M = TreeZipperT (StateT Unique);

var run = \m s ctx seed ->
    Unique.runUnique(
        StateT.evalStateT(
            TreeZipperT.runTreeZipperT(m, ctx),
            s),
        seed);

var pass = M.of null;

var cons = liftM2 @ concat;

var enumeration = fun.foldr@(flip cons, M.of []);

/* Operations
 ******************************************************************************/
// State Operations
////////////////////////////////////////
var extract = M.lift (M.inner.get);

var setState = M.lift <\ M.inner.put;

var modifyState = M.lift <\ M.inner.modify;

var inspectStateWith = M.chain @ extract;

// Zipper Operations
////////////////////////////////////////
var node = M.node;

var withNode = M.chain @ node;

var modify = M.modifyNode;
var set = M.setNode;

// Scoping Operations
////////////////////////////////////////
var inspectScope = \f -> extract.map (f <\ (.scope));

var inspectScopeWith = \f -> extract.chain(f <\ (.scope));

var packageManager = extract.map (.packageManager);

var setScope = \scope ->
    modifyState \ s ->
        s.setScope(scope);

var modifyScope = \f ->
    modifyState \ s ->
        s.setScope(f s.scope);

/**
 * Enter a new real scope.
 */
var enterBlock = modifyScope (scope.push);

/**
 * Exit the current real scope.
 */
var exitBlock = modifyScope (scope.pop);

/**
 * Get the identifier name for `uid`.
 */
var getMapping = \uid ->
    inspectScope \ s ->
        s.getMapping(uid);

/**
 * Add an new identifier in the current scope.
 * 
 * @param id Source id name.
 * @param uid Unique id.
 */
var addVar = \id uid ->
    inspectScopeWith \ s ->
        ?s.hasMapping(uid)
            :setScope <|
                scope.addMutableBinding(s, id)
            
        :let name = s.getUnusedId(id) in
            setScope <|
                scope.addMapping(
                    scope.addMutableBinding(s, name),
                    uid,
                    name);

// Bindings Operations
////////////////////////////////////////
var setBindings = \bindings ->
    modifyState \ s ->
        s.setBindings(bindings);

var pushBindings = modifyState \ s ->
    s.setBindings [[], s.bindings];

var popBindings = modifyState \ s ->
    s.setBindings(s.bindings.(1));

var addBindings = \bindings ->
    modifyState \ s ->
        s.setBindings [s.bindings.(0).concat(bindings), s.bindings.(1)];

/**
 * Get all bindings in the current scope.
 */
var getBindings = M.chain @ inspectStateWith(
    enumeration
    <\ (fun.map @ \[name uid] -> getMapping(uid))
    <\ \s -> s.bindings.(0));

/* Forward
 ******************************************************************************/
var _trans;

var _transform = withNode \node -> _trans(node); // Late

/* Unpacks
 ******************************************************************************/
/**
 * Expand a binding to a list of simple variable declarations.
 */
var unpack =
    expandBinding
    \> fun.map @ \x ->
        variableDeclarator(null, x.pattern.id, x.value);

/**
 * Expand an binding to a list of assignment expressions.
 */
var unpackAssign =
    expandBinding
    \> fun.map @ \x ->
        ecma_expression.AssignmentExpression.create(null, '=', x.pattern, x.value);

/**
 * Expand an arguments pattern to a list of bindings.
 */
var unpackArgumentsPattern = \parameters -> let
    elementsPrefix = unpackParameters(parameters.id, parameters.elements),
    
    selfPrefix = ?parameters.self
        :expandBindings(
            ecma_expression.ThisExpression.create(null),
            parameters.self)
        :[],
    
    argumentsPrefix = ?parameters.id
        :expandBindings(
            identifier(null, 'arguments'),
            parameters.id)
        :[]
in
    flatten <| concat(
        argumentsPrefix,
        elementsPrefix,
        selfPrefix);

/* Statements
 ******************************************************************************/
/**
 * With statement translation.
 */
var withStatementNoImport = \loc bindings body -> let
    vars = flatten <| fun.map(unpack, bindings),
    
    prefix = variableDeclaration(null, vars)
in
    khepri_statement.BlockStatement.create(loc,
        concat(
            prefix,
            body.body));

/**
 * With statement translation.
 */
var withStatement = \packageManager, loc, bindings, body -> let
    flattenImport = \imp ->
        ?type imp === 'ImportPattern'
            :khepri_declaration.Binding.create(null,
                imp.pattern,
                packageManager.importPackage(imp.from.value))
            :imp
in
    withStatementNoImport(loc,
        fun.map(flattenImport, bindings),
        body);

/* Expressions
 ******************************************************************************/
/**
 * Function Expression Normalization.
 */
var functionExpression = \loc id parameters functionBody prefix -> let
    params = parameters.elements,
        
    bindings = unpackArgumentsPattern(parameters)
        |> fun.map @ \x -> variableDeclarator(null, x.pattern, x.value),
    
    body = ?type functionBody === "BlockStatement"
        :functionBody
        :khepri_statement.BlockStatement.create(null,
            khepri_statement.ReturnStatement.create(null, functionBody))
in
    khepri_expression.FunctionExpression.create(loc,
        id,
        params,
        khepri_statement.BlockStatement.create(body.loc,
            concat(
                (prefix || []),
                ?bindings.length
                    :variableDeclaration(null, bindings)
                    :[],
                body.body)));

/**
 * Let expression normalization.
 */
var letExpression = \loc bindings body ->
    ecma_expression.SequenceExpression.create(null,
        flatten concat(
            fun.map(unpackAssign, bindings),
            body));

/**
 * Curry expression translation.
 */
var curryExpression = \loc base args ->
    khepri_expression.CallExpression.create(loc,
        khepri_expression.MemberExpression.create(null,
            base,
            identifier(null, 'bind')),
        concat(
            nullLiteral(null),
            args));

/* Package
 ******************************************************************************/
var packageBlock = \packageManager loc exports body -> let
    imports =
        ?type body === 'WithStatement'
            :filter(type \> (===, 'ImportPattern'), body.bindings)
            :[],
    
    targets =
        fun.reduce(imports, \p c -> {
            p.(c.from.value) = c.pattern;
            return p;
        }, {}),
    
    fBody =
        ?type body === 'WithStatement'
            :khepri_statement.WithStatement.create(null,
                filter(type \> (!==, 'ImportPattern'), body.bindings),
                body.body)
            :body
in
    packageManager.definePackage(loc,
        exports,
        imports,
        targets,
        fBody);

/* Transform
 ******************************************************************************/
var transformers = {};

var addTransform = \type pre post -> {
    if (Array.isArray(type))
        return type.map \ x -> addTransform(x, pre, post);
    
   transformers.(type) = {
        pre: pre,
        post: post
    };
};

// Declarations
addTransform('VariableDeclaration',
    null,
    modify \ {loc declarations} ->
        ecma_declaration.VariableDeclaration.create(loc,
            declarations));

addTransform('VariableDeclarator',
    null,
    modify \ node ->
        ecma_declaration.VariableDeclarator.create(node.loc,
            node.id,
            node.init));

addTransform('StaticDeclaration',
    modify \ {loc} ->
        ecma_statement.EmptyStatement.create(loc));

// Clauses
addTransform('CatchClause',
    null,
    modify \ node ->
        ecma_clause.CatchClause.create(node.loc,
            node.param,
            node.body));

addTransform('SwitchCase',
    null,
    modify \ node ->
        ecma_clause.SwitchCase.create(node.loc,
            node.test,
            node.consequent));

// Statement
addTransform('BlockStatement',
    pushBindings,
    seq(
        getBindings \ bindings ->
            modify \ node ->
                ecma_statement.BlockStatement.create(node.loc,
                    concat(
                        ecma_declaration.VariableDeclaration.create(null,
                            bindings.map(\x ->
                                ecma_declaration.VariableDeclarator.create(null,
                                    identifier(null, x)))),
                        node.body)),
        popBindings));

addTransform('ExpressionStatement',
    null,
    modify \ node ->
        ecma_statement.ExpressionStatement.create(node.loc,
            node.expression));

addTransform('IfStatement',
    null,
    modify \ node ->
        ecma_statement.IfStatement.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('WithStatement',
    next(
        packageManager.chain \ packageManager -> 
            modify \ node ->
                withStatement(
                    packageManager,
                    node.loc,
                    node.bindings,
                    node.body),
        _transform));

addTransform('SwitchStatement',
    null,
    modify \ node ->
        ecma_statement.SwitchStatement.create(node.loc,
            node.discriminant,
            node.cases));

addTransform('ReturnStatement',
    null,
    modify \ node ->
        ecma_statement.ReturnStatement.create(node.loc,
            node.argument));

addTransform('ThrowStatement',
    null,
    modify \ node ->
        ecma_statement.ThrowStatement.create(node.loc,
            node.argument));

addTransform('BreakStatement',
    modify \ node ->
        ecma_statement.BreakStatement.create(node.loc,
            null));

addTransform('ContinueStatement',
    modify \ node ->
        ecma_statement.ContinueStatement.create(node.loc,
            null));

addTransform('TryStatement',
    null,
    modify \ node ->
        ecma_statement.TryStatement.create(node.loc,
            node.block,
            node.handler,
            node.finalizer));

addTransform('WhileStatement',
    null,
    modify \ node ->
        ecma_statement.WhileStatement.create(node.loc,
            node.test,
            node.body));

addTransform('DoWhileStatement',
    null,
    modify \ node ->
        ecma_statement.DoWhileStatement.create(node.loc,
            node.body,
            node.test));

addTransform('ForStatement',
    null,
    modify \ node ->
        ecma_statement.ForStatement.create(node.loc,
            node.init,
            node.test,
            node.update,
            node.body));

// Expression
addTransform('AssignmentExpression',
    null,
    modify \ node ->
        ecma_expression.AssignmentExpression.create(node.loc,
            '=',
            node.left,
            node.right));

addTransform('UnaryExpression',
    null,
    modify \ node ->
        ecma_expression.UnaryExpression.create(node.loc,
            ?node.operator === '++'
                :'+'
            :?node.operator === '--'
                :'-'
            :node.operator,
            node.argument));

addTransform('BinaryExpression',
    null,
    modify \ node ->
        ecma_expression.BinaryExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('LogicalExpression',
    null,
    modify \ node ->
        ecma_expression.LogicalExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('ConditionalExpression',
    null,
    modify \ node ->
        ecma_expression.ConditionalExpression.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('NewExpression',
    null,
    modify \ node ->
        ecma_expression.NewExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('CallExpression',
    null,
    modify \ node ->
        ecma_expression.CallExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('MemberExpression',
    null,
    modify \ node ->
        ecma_expression.MemberExpression.create(node.loc,
            node.object,
            node.property,
            node.computed));

addTransform('LetExpression',
    seq(
        withNode \ node -> let
            bindings = flatten <| fun.map(\x -> ?x : expandBindings(null, x.pattern) : [], node.bindings),
            identifiers = fun.map(\x -> [x.pattern.id.name, getUid(x.pattern.id)], bindings)
        in
            addBindings(identifiers),
        
        modify \ node ->
            letExpression(node.loc,
                node.bindings,
                node.body)));

addTransform('CurryExpression',
    modify \ node ->
        curryExpression(node.loc,
            node.base,
            node.args));

addTransform('FunctionExpression',
    seq(
        enterBlock,
        modify \ node ->
            functionExpression(node.loc,
                node.id,
                node.params,
                node.body,
                node.ud && node.ud.prefix)),
    seq(
        modify \ node ->
            ecma_expression.FunctionExpression.create(null,
                node.id,
                node.params,
                node.body),
        exitBlock));

addTransform('ArrayExpression',
    null,
    modify \ node ->
        ecma_expression.ArrayExpression.create(node.loc,
            node.elements));

addTransform('ObjectExpression',
    null,
    modify \ node ->
        ecma_expression.ObjectExpression.create(node.loc,
            node.properties));

addTransform('ObjectValue',
    null,
    modify \ node ->
        ecma_value.ObjectValue.create(node.loc,
            node.key,
            node.value));

// Patterns
addTransform(['IdentifierPattern', 'AsPattern', 'ArgumentsPattern'],
    null,
    modify (.id));

addTransform(['ObjectPattern', 'EllipsisPattern', 'SinkPattern'],
    null,
    modify \ node ->
        (node.ud && node.ud.id));

// Program
addTransform('Program',
    let
        useStrict =
            khepri_statement.ExpressionStatement.create(null,
                khepri_value.Literal.create(null, 'string', "use strict"))
    in
        seq(
            pushBindings,
            modify \ node ->
                ?type node.body === 'Package'
                    :node
                    :setData(node, 'prefix', useStrict)),
        
    getBindings \ bindings ->
    modify \ node ->
        ecma_program.Program.create(node.loc,
            concat(
                ?node.ud && node.ud.prefix :node.ud.prefix :[],
                ecma_declaration.VariableDeclaration.create(null,
                    bindings.map\x ->
                        ecma_declaration.VariableDeclarator.create(null,
                            identifier(null, x))),
                node.body)));

// Package
addTransform('Package',
    packageManager.chain \ packageManager ->
    modify \ node ->
        packageBlock(
            packageManager,
            node.loc,
            node.exports,
            node.body));

// Value
addTransform('Identifier',
    null,
    withNode \ node ->
        ?getUid node
            // When node has uid, get mapped name for uid.
            :next(
                addVar(node.name, getUid node),
                getMapping(getUid node).chain \ name ->
                    set <| identifier(node.loc, name))
        
        // When node has no uid, don't rename
        :set <| identifier(node.loc, node.name));

/*
 *****************************************************************************/
_trans = \node ->
    ?node instanceof khepri_node.Node
        :let t = transformers.(type node) in
            (t && t.pre) || pass
    :pass;

var _transp = \node ->
    ?node instanceof khepri_node.Node
        :let t = transformers.(type node) in
            (t && t.post) || pass
    :pass;

var _transformPost = withNode _transp;

/* API
 *****************************************************************************/
/**
 * Rewrite a Khepri zippered program to an ECMAScript program.
 * 
 * Outputs the ECMAScript root.
 * 
 * @param ast Zippered khepri program.
 * @param manager Package manager to use for rewrite.
 */
transform = \ast manager -> {
    with 
        import './package_manager/amd' amd_manager,
        import './package_manager/node' node_manager
    in {
        var packageManager = amd_manager;
        if (manager === 'node')
            packageManager = node_manager;
        
        var s = State.empty
            .setPackageManager(packageManager);
        
        return run(
            seq(
                addVar('require', getUid(builtins.require)),
                addVar('exports', getUid(builtins.exports)),
                walk(M, _transform, _transformPost),
                node),
            s,
            ast);
    }
};

}
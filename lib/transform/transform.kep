/**
 * @fileOverview
 */
package (
    transform)
with 
    import 'bes::record' record,

    import 'ecma-ast::clause' ecma_clause,
    import 'ecma-ast::declaration' ecma_declaration,
    import 'ecma-ast::expression' ecma_expression,
    import 'ecma-ast::node' ecma_node,
    import 'ecma-ast::program' ecma_program,
    import 'ecma-ast::statement' ecma_statement,
    import 'ecma-ast::value'ecma_value,
    
    import 'khepri-ast::declaration' khepri_declaration,
    import 'khepri-ast::expression' khepri_expression,
    import 'khepri-ast::node' khepri_node#{setData},
    import 'khepri-ast::pattern' khepri_pattern,
    import 'khepri-ast::program' khepri_program,
    import 'khepri-ast::statement' khepri_statement,
    import 'khepri-ast::value' khepri_value,
    
    import 'khepri-ast-zipper' {khepriZipper},
    
    import 'akh::unique' Unique,
    import 'akh::trans::state' StateT,
    import 'akh::base' {
        next
        'sequence': seq
        'sequencea': seqa},
    
    import 'zipper-m::trans::zipper' ZipperT,
    import 'zipper-m::walk' walk,
    
    import '../ast' {getUid},

    import '../scope' scope,
    import '../fun' fun#{flip},
    import '../builtin' {builtins definitions},
    import '../unpack' {innerPattern unpackParameters},
    
    import './package_manager::amd' _,
    import './package_manager::node' _
in {

/* Monad
 ******************************************************************************/
var M = ZipperT (StateT Unique);

var run = \m s ctx seed ->
    Unique.runUnique(
        StateT.evalStateT(
            ZipperT.runZipperT(m, ctx),
            s),
        seed);

var ok = M.of;

var pass = ok null;

var cons = \a b ->
    a.chain \ x ->
    b.map \ y ->
        [x].concat(y);

var enumeration = fun.foldr@(flip cons, ok []);

/* State
 ******************************************************************************/
var State = record.declare(null, [
    'scope',
    'packageManager',
    'bindings',
    'globals']);

State.empty = State.create(scope.Scope.empty, null, [[], null], []);

/* Operations
 ******************************************************************************/
// State Operations
////////////////////////////////////////
var extract = M.lift (M.inner.get);

var setState = M.lift <\ M.inner.put;

var modifyState = M.lift <\ M.inner.modify;

var inspectStateWith = M.chain @ extract;

var globals = extract.map\s -> s.globals;


// Zipper Operations
////////////////////////////////////////
var node = M.node;

var modify = M.modifyNode;

var set = M.setNode;

var withNode = node.chain.bind(node);

// Scoping Operations
////////////////////////////////////////
var inspectScope = \f -> extract.map\s -> f(s.scope);

var inspectScopeWith = \f -> extract.chain\s -> f(s.scope);

var packageManager = extract.map\s -> s.packageManager;

var modifyScope = \f ->
    modifyState \ s ->
        s.setScope(f s.scope);

var setScope = \s -> modifyScope(\() -> s);

/**
 * Enter a new real scope.
 */
var enterBlock = inspectScopeWith \ s ->
    setScope(scope.Scope.empty.setOuter(s));

/**
 * Exit the current real scope.
 */
var exitBlock = inspectScopeWith \ s ->
    setScope(s.outer);

/**
 * Get the identifier name for `uid`.
 */
var getMapping = \uid ->
    inspectScope \ s ->
        s.getMapping(uid);

/**
 * Add an new identifier in the current scope.
 * 
 * @param id Source id name.
 * @param uid Unique id.
 */
var addVar = \id uid ->
    inspectScopeWith \ s ->
        ?s.hasMapping(uid)
            :setScope(scope.Scope.addMutableBinding(s, id))
            :let name = s.getUnusedId(id) in
                setScope(scope.Scope.addMapping(
                    scope.Scope.addMutableBinding(s, name),
                    uid,
                    name));

// Bindings Operations
////////////////////////////////////////
var setBindings = \bindings ->
    modifyState \ s ->
        s.setBindings(bindings);

var pushBindings = modifyState \ s ->
    s.setBindings([[], s.bindings]);

var popBindings = modifyState \ s ->
    s.setBindings(s.bindings.(1));

var addBindings = \bindings ->
    modifyState(\s -> s.setBindings([s.bindings.(0).concat(bindings), s.bindings.(1)]));

/**
 * Get all bindings in the current scope.
 */
var getBindings = M.chain @ inspectStateWith(
    enumeration
    <\ (fun.map @ \[name uid] -> getMapping(uid))
    <\ \s -> s.bindings.(0));

/* Forward
 ******************************************************************************/
var _trans;

var _transform = withNode \node -> _trans(node); // Late

/* Values
 ******************************************************************************/
var identifier = \loc, name ->
    ecma_value.Identifier.create(loc, name);

var stringLiteral = \loc, value ->
    ecma_value.Literal.create(loc, 'string', value);

var nullLiteral = \loc ->
    ecma_value.Literal.create(loc, 'null', null);

/* Declaration
 ******************************************************************************/
var variableDeclaration = khepri_declaration.VariableDeclaration.create;

var variableDeclarator = ecma_declaration.VariableDeclarator.create;

/* Unpacks
 ******************************************************************************/
/**
 * Expand an unpack pattern to a list of variable declarators.
 */
var unpack =
    innerPattern
    \>> fun.flatten
    \> (fun.map @ \x -> variableDeclarator(null, x.pattern, x.value));

/**
 * Expand an unpack pattern to a list of assignment expressions.
 */
var unpackAssign =
    innerPattern
    \>> fun.flatten
    \> (fun.map @ \x -> ecma_expression.AssignmentExpression.create(null,'=', x.pattern, x.value));

/**
 * Expand an arguments pattern to a list of bindings.
 */
var unpackArgumentsPattern = \parameters -> let
    elementsPrefix = unpackParameters(parameters.elements),
    
    selfPrefix = ?parameters.self
        :innerPattern(
            ecma_expression.ThisExpression.create(null),
            parameters.self)
        :[],
    
    argumentsPrefix = ?parameters.id
        :innerPattern(
            identifier(null, 'arguments'),
            parameters.id)
        :[]
in
    fun.concat(
        elementsPrefix,
        selfPrefix,
        argumentsPrefix)
        |> fun.flatten;

/* Statements
 ******************************************************************************/
/**
 * With statement translation.
 */
var withStatementNoImport = \loc, bindings, body -> let
    vars = fun.map(
        \imp -> unpack(imp.value, imp.pattern),
        bindings),
    
    prefix = variableDeclaration(null, vars)
in
    khepri_statement.BlockStatement.create(loc,
        fun.concat(
            prefix,
            body.body));

/**
 * With statement translation.
 */
var withStatement = \packageManager, loc, bindings, body -> let
    flattenImport = \imp ->
        ?imp && imp.type === 'ImportPattern'
            :khepri_declaration.Binding.create(null,
                imp.pattern,
                packageManager.importPackage(imp.from.value))
            :imp
in
    withStatementNoImport(loc,
        fun.map(flattenImport, bindings),
        body);

/* Expressions
 ******************************************************************************/
/**
 * Function Expression Normalization.
 */
var functionExpression = \loc, id, parameters, functionBody, prefix -> let
    params = parameters.elements
        |> (fun.filter@\x -> x.type !== 'EllipsisPattern'),
        
    bindings = unpackArgumentsPattern(parameters)
        |> (fun.map @ \x -> variableDeclarator(null, x.pattern, x.value)),
    
    body = ?functionBody.type === "BlockStatement"
        :functionBody
        :khepri_statement.BlockStatement.create(null,
            khepri_statement.ReturnStatement.create(null, functionBody))
in
    khepri_expression.FunctionExpression.create(loc,
        id,
        params,
        khepri_statement.BlockStatement.create(body.loc,
            fun.concat(
                (prefix || []),
                ?bindings.length
                    :variableDeclaration(null, bindings)
                    :[],
                body.body)));

/**
 * Let expression normalization.
 */
var letExpression = \loc, bindings, body ->
    ecma_expression.SequenceExpression.create(null,
        fun.flatten <| fun.concat(
            fun.map(\x ->
                ?x
                    :unpackAssign(x.value, x.pattern)
                    :[],
                bindings),
            body));

/**
 * Curry expression translation.
 */
var curryExpression = \loc, base, args ->
    khepri_expression.CallExpression.create(null,
        khepri_expression.MemberExpression.create(null,
            base,
            identifier(null, 'bind')),
        fun.concat(
            nullLiteral(null),
            args));

/* Package
 ******************************************************************************/
var packageBlock = \packageManager, loc, exports, globals body -> let
    imports = ?body.type === 'WithStatement'
        :fun.filter(\x -> x && x.type === 'ImportPattern', body.bindings)
        :[],
    
    targets = fun.reduce(imports, \p c -> {
        p.(c.from.value) = c.pattern;
        return p;
    }, {}),
    
    fBody = ?body.type === 'WithStatement'
        :khepri_statement.WithStatement.create(null,
            fun.filter(\x -> x && x.type !== 'ImportPattern', body.bindings),
            body.body)
        :body
in
    packageManager.definePackage(loc,
        exports,
        imports,
        targets,
        globals,
        fBody);

/* Transform
 ******************************************************************************/
var transformers = {};

var addTransform = \type pre post -> {
    var entry = {
        'pre': pre,
        'post': post
    };
    
    transformers.(type) = ?transformers.(type)
        :transformers.(type).concat(entry)
        :[entry];
};

// Declarations
addTransform('VariableDeclaration',
    null,
    modify \ {loc declarations} ->
        ?declarations.length
            :ecma_declaration.VariableDeclaration.create(loc,
                declarations)
            :null);

addTransform('VariableDeclarator',
    null,
    modify \ node ->
        ecma_declaration.VariableDeclarator.create(node.loc,
            node.id,
            node.init));

addTransform('StaticDeclaration',
    modify \ node ->
        ecma_statement.EmptyStatement.create(node.loc));

// Clauses
addTransform('CatchClause',
    null,
    modify \ node ->
        ecma_clause.CatchClause.create(node.loc,
            node.param,
            node.body));

addTransform('SwitchCase',
    null,
    modify \ node ->
        ecma_clause.SwitchCase.create(node.loc,
            node.test,
            node.consequent));

// Statement
addTransform('BlockStatement',
    pushBindings,
    seq(
        getBindings \ bindings ->
            modify \ node ->
                ecma_statement.BlockStatement.create(node.loc,
                    fun.concat(
                        ecma_declaration.VariableDeclaration.create(null,
                            bindings.map(\x ->
                                ecma_declaration.VariableDeclarator.create(null,
                                    identifier(null, x)))),
                        node.body)),
        popBindings));

addTransform('ExpressionStatement',
    null,
    modify \ node ->
        ecma_statement.ExpressionStatement.create(node.loc,
            node.expression));

addTransform('IfStatement',
    null,
    modify \ node ->
        ecma_statement.IfStatement.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('WithStatement',
    next(
        packageManager.chain \ packageManager -> 
            modify \ node ->
                withStatement(
                    packageManager,
                    node.loc,
                    node.bindings,
                    node.body),
        _transform));

addTransform('SwitchStatement',
    null,
    modify \ node ->
        ecma_statement.SwitchStatement.create(node.loc,
            node.discriminant,
            node.cases));

addTransform('ReturnStatement',
    null,
    modify \ node ->
        ecma_statement.ReturnStatement.create(node.loc,
            node.argument));

addTransform('ThrowStatement',
    null,
    modify \ node ->
        ecma_statement.ThrowStatement.create(node.loc,
            node.argument));

addTransform('BreakStatement',
    modify \ node ->
        ecma_statement.BreakStatement.create(node.loc,
            null));

addTransform('ContinueStatement',
    modify \ node ->
        ecma_statement.ContinueStatement.create(node.loc,
            null));

addTransform('TryStatement',
    null,
    modify \ node ->
        ecma_statement.TryStatement.create(node.loc,
            node.block,
            node.handler,
            node.finalizer));

addTransform('WhileStatement',
    null,
    modify \ node ->
        ecma_statement.WhileStatement.create(node.loc,
            node.test,
            node.body));

addTransform('DoWhileStatement',
    null,
    modify \ node ->
        ecma_statement.DoWhileStatement.create(node.loc,
            node.body,
            node.test));

addTransform('ForStatement',
    null,
    modify \ node ->
        ecma_statement.ForStatement.create(node.loc,
            node.init,
            node.test,
            node.update,
            node.body));

// Expression
addTransform('AssignmentExpression',
    null,
    modify \ node ->
        ecma_expression.AssignmentExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('UnaryExpression',
    null,
    modify \ node -> {
        var op = node.operator;
        switch (op) {
        case '++': op = '+'; break;
        case '--': op = '-'; break;
        }
        
        return ecma_expression.UnaryExpression.create(node.loc,
            op,
            node.argument);
    });

addTransform('BinaryExpression',
    null,
    modify \ node ->
        ecma_expression.BinaryExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('LogicalExpression',
    null,
    modify \ node ->
        ecma_expression.LogicalExpression.create(node.loc,
            node.operator,
            node.left,
            node.right));

addTransform('ConditionalExpression',
    null,
    modify \ node ->
        ecma_expression.ConditionalExpression.create(node.loc,
            node.test,
            node.consequent,
            node.alternate));

addTransform('NewExpression',
    null,
    modify \ node ->
        ecma_expression.NewExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('CallExpression',
    null,
    modify \ node ->
        ecma_expression.CallExpression.create(node.loc,
            node.callee,
            node.args));

addTransform('MemberExpression',
    null,
    modify \ node ->
        ecma_expression.MemberExpression.create(node.loc,
            node.object,
            node.property,
            node.computed));

addTransform('LetExpression',
    seq(
        withNode \ node -> let
            bindings = fun.flatten <| fun.map(\x -> ?x : innerPattern(null, x.pattern) : [], node.bindings),
            identifiers = fun.map(\x -> [x.pattern.id.name, getUid(x.pattern.id)], bindings)
        in
            addBindings(identifiers),
        modify \ node ->
            letExpression(node.loc,
                node.bindings,
                node.body)));

addTransform('CurryExpression',
    modify \ node ->
        curryExpression(node.loc,
            node.base,
            node.args));

addTransform('FunctionExpression',
    seq(
        enterBlock,
        modify \ node ->
            functionExpression(node.loc,
                node.id,
                node.params,
                node.body,
                node.ud && node.ud.prefix)),
    seq(
        modify \ node ->
            ecma_expression.FunctionExpression.create(null,
                node.id,
                node.params,
                node.body),
        exitBlock));

addTransform('ArrayExpression',
    null,
    modify \ node ->
        ecma_expression.ArrayExpression.create(node.loc,
            node.elements));

addTransform('ObjectExpression',
    null,
    modify \ node ->
        ecma_expression.ObjectExpression.create(node.loc,
            node.properties));

addTransform('ObjectValue',
    null,
    modify \ node ->
        ecma_value.ObjectValue.create(node.loc,
            node.key,
            node.value));

// Patterns
addTransform('IdentifierPattern',
    null,
    modify \ node ->
        node.id);

addTransform('ArgumentsPattern',
    null,
    modify \ node ->
        node.id);

addTransform('AsPattern',
    null,
    modify \ node ->
        node.id);

addTransform('ObjectPattern',
    null,
    modify \ node ->
        node.ud.id);

addTransform('EllipsisPattern',
    modify \ node ->
        (node.ud && node.ud.id));

addTransform('SinkPattern',
    modify \ node ->
        (node.ud && node.ud.id));

// Program
addTransform('Program',
    seq(
        pushBindings,
        globals.chain \ globals ->
        modify \ node ->
            ?node.body.type === 'Package'
                :node
                :setData(khepri_program.Program.create(null, fun.concat(globals, node.body)), 'prefix',
                    khepri_statement.ExpressionStatement.create(null,
                        khepri_value.Literal.create(null, 'string', "use strict")))),
    
    getBindings \ bindings ->
    modify \ node ->
        ecma_program.Program.create(node.loc,
            fun.concat(
                ?node.ud && node.ud.prefix :node.ud.prefix :[],
                ecma_declaration.VariableDeclaration.create(null,
                    bindings.map(\x ->
                        ecma_declaration.VariableDeclarator.create(null,
                            identifier(null, x)))),
                node.body)));

// Package
addTransform('Package',
    packageManager.chain \packageManager ->
    globals.chain \ globals ->
    modify \ node ->
        packageBlock(
            packageManager,
            node.loc,
            node.exports,
            globals,
            node.body));

// Value
addTransform('Identifier',
    null,
    withNode \ node ->
        ?getUid node
            :next(
                addVar(node.name, getUid(node)),
                getMapping(getUid node).chain\name ->
                    set <| identifier(node.loc, name))
            :set <| identifier(node.loc, node.name));

/*
 *****************************************************************************/
_trans = \node -> {
    if (node && node instanceof khepri_node.Node) {
        var t = transformers.(node.type);
        if (t && t.(0).pre)
            return t.(0).pre;
    }
    return pass;
};

var _transp = \node -> {
    if (node && node instanceof khepri_node.Node) {
        var t = transformers.(node.type);
        if (t && t.(0).post)
            return t.(0).post;
    }
    return pass;
};

var _transformPost = withNode _transp;

/* API
 *****************************************************************************/
/**
 * 
 */
transform = \ast manager data -> {
    with 
        import './package_manager/amd' amd_manager,
        import './package_manager/node' node_manager
    in {
        var packageManager = amd_manager;
        if (manager === 'node')
            packageManager = node_manager;
        
        var globals = data.globals;
        
        var s = State.empty
            .setScope(scope.Scope.empty)
            .setPackageManager(packageManager)
            .setGlobals(?data.globals : khepri_declaration.VariableDeclaration.create(null,data.globals.map(\x ->
                khepri_declaration.VariableDeclarator.create(null, builtins.(x), definitions.(x)))) : []);
        
        return run(
            seq(
                addVar('require', getUid(builtins.require)),
                addVar('exports', getUid(builtins.exports)),
                walk(M, _transform, _transformPost),
                node),
            s,
            khepriZipper ast);
    }
};

}
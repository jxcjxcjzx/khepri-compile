/**
 * @fileOverview ECMAScript AST peephole optimization pass.
 */
package (
    optimize)
with
    import 'ecma-ast-zipper' {ecmaZipper},
    
    import 'ecma-ast::node' {modify},
    import 'ecma-ast::value' ast_value,
    import 'ecma-ast::declaration' ast_declaration,
    import 'ecma-ast::statement' ast_statement,
    import 'ecma-ast::expression' ast_expression,
    
    import './fun' fun,
    import './rewritter' {
        UP
        DOWN
        Rewritter
        rewrite}
in {

var peepholes = new Rewritter();

/* Peepholes
 ******************************************************************************/
/**
 * Filter out empty variable declarators.
 */
peepholes.add(['VariableDeclaration'], false,
    \_ -> true, 
    \node -> let
        declarations = node.declarations.filter(\x -> !!x)
    in
        modify(node, {
            'declarations': declarations
        }, {}));

/**
 * Remove empty Variable declarations.
 */
peepholes.add(['VariableDeclaration'], true,
    \node -> !node.declarations.length,
    \_ -> null);

/**
 * Reduce block statements
 */
peepholes.add(['Program', 'BlockStatement'], true,
    \_ -> true,
    \node ->
        modify(node, {
            'body': fun.flatten(node.body.map(\x ->
                ?x && x.type === 'BlockStatement' :x.body :x))
        }, {}));

/**
 * Merge var declarations
 */
peepholes.add(['Program', 'BlockStatement'], true,
    \_ -> true,
    \node ->
        modify(node, {
            'body': node.body.reduceRight(\p c ->
                ?(c && c.type === 'VariableDeclaration' && p.length && p.(0) && p.(0).type === 'VariableDeclaration')
                    :fun.concat(modify(c, {
                        'declarations': fun.concat(c.declarations, p.(0).declarations)
                    }, {}), p.slice(1))
                    :fun.concat(c, p),
                [])
            }, {}));

/**
 * Remove top level empty statements
 */
peepholes.add(['Program', 'BlockStatement'], true,
    \_ -> true,
    \node ->
        modify(node, {
            'body': fun.flatten(node.body.map(\x ->
                ?!x || x.type === 'EmptyStatement' :[] :x))
            }, {}));


/* Interface
 ******************************************************************************/
optimize = \ast -> 
    rewrite(peepholes, ecmaZipper(ast));

}

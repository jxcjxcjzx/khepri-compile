/**
 * @fileOverview Post-lexical check tree normalization.
 * 
 * This stage is run once after identifiers have been assigned uids by lexical
 * check.
 * 
 * It rewrites complex Khepri statements to simplified forms that can be 
 * better optimized and transformed by later stages.
 */
package (
    normalize)
with
    import 'khepri-ast-zipper' {khepriZipper},
    
    import 'khepri-ast::statement' ast_statement,
    import 'khepri-ast::expression' ast_expression,
    import 'khepri-ast::pattern' ast_pattern,
    import 'khepri-ast::value' ast_value,
    
    import './ast' {
        isBlockFunction},
    import './fun' {
        concat
        flattenr
        filter
        map},
    import './unpack' {
        innerPattern
        unpackParameters},
    import './builtin' {
        builtins
        definitions},
    import './rewritter' {
        UP
        DOWN
        Rewritter
        rewrite}
in {

var always := \_ -> true;

/* Transforms
 ******************************************************************************/
var peepholes = new Rewritter();

/* Binding Expansion
 ******************************************************************************/
/**
 * Expand potentially complex let expression bindings patterns to a list of simple
 * identifier bindings.
 */
peepholes.add(['LetExpression'], UP,
    always,
    
    let
        expandBinding = \binding -> innerPattern(binding.value, binding.pattern, binding.recursive)
    in
        \node ->
            ast_expression.LetExpression.create(node.loc,
                flattenr <| map(expandBinding, node.bindings),
                node.body));

/**
 * Expand potentially complex parameter patterns in a function to simple
 * identifier patterns for the arguments with a binding body to unpack
 * complex parameter binding values.
 */
peepholes.add(['FunctionExpression'], UP,
    always,
    
    \node -> let
        params = node.params.elements
            |> (filter @ \x -> x.type !== 'EllipsisPattern')
            |> (map @ \x -> {
                switch (x.type) {
                case 'IdentifierPattern':
                    return x;
                default:
                    return ast_pattern.IdentifierPattern.create(null,
                        (x.id && x.id.id) || x.ud.id);
                }
            }),
        
        bindings = unpackParameters(node.params.elements),
        
        body = ?isBlockFunction node
            :ast_statement.BlockStatement.create(null,
                [ast_statement.WithStatement.create(null,
                    bindings,
                    node.body)])
            :ast_expression.LetExpression.create(null,
                bindings,
                node.body)
    in
        ast_expression.FunctionExpression.create(null,
            node.id,
            ast_pattern.ArgumentsPattern.create(null,
                node.params.id,
                params,
                node.params.self),
            body));

/* Expression Conversion
 ******************************************************************************/
var expandAssignment := \node ->
    ?node.right.type === 'AssignmentExpression'
        :let right = expandAssignment(node.right) in
            concat(
                right,
                ast_expression.AssignmentExpression.create(null, '=',
                    node.left,
                    right.(right.length - 1).left))
        :[node];

/**
 * Rewrite a potentially compound assignment expression to a list of single
 * assignments.
 */
peepholes.add(['ExpressionStatement'], UP,
    \{expression} ->
        (expression.type === 'AssignmentExpression'),
    
    \node ->
        ast_statement.BlockStatement.create(null,
            expandAssignment(node.expression)
                |> flattenr
                |> map @ (ast_statement.ExpressionStatement.create@null)));

/**
 * Rewrite left pipe to a call.
 */
peepholes.add(['BinaryExpression'], UP,
    \node ->
        (node.operator === '|>'),
    
    \{left right} ->
        ast_expression.CallExpression.create(null,
            right,
            [left]));

/**
 * Rewrite right pipe to a call.
 */
peepholes.add(['BinaryExpression'], UP,
    \node->
        (node.operator === '<|'),
    
    \{left right} ->
        ast_expression.CallExpression.create(null,
            left,
            [right]));

/**
 * Rewrite compose to use builtin compose code.
 */
peepholes.add(['BinaryExpression'], UP,
    \node->
        (  node.operator === '\\>'
        || node.operator === '\\>>'
        || node.operator === '<\\'
        || node.operator === '<<\\'),
    
    \{operator left right} ->
        ast_expression.CallExpression.create(null,
            definitions.(operator),
            [left, right]));

/* Interface
 ******************************************************************************/
normalize = khepriZipper \> rewrite @ peepholes;

}
